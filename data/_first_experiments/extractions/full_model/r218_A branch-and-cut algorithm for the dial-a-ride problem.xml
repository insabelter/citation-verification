<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Branch-and-Cut Algorithm for the Dial-a-Ride Problem</title>
				<funder ref="#_2A4N8TM">
					<orgName type="full">Natural Sciences and Engineering Research Council of Canada</orgName>
				</funder>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability  status="unknown">
					<licence/>
				</availability>
				<date type="published" when="2003-10-28">October 28, 2003</date>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Jean-Franc</forename><forename type="middle">¸ois</forename><surname>Cordeau</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Research Chair in Distribution Management</orgName>
								<orgName type="institution">HEC Montréal</orgName>
								<address>
									<addrLine>3000 chemin de la Côte-Sainte-Catherine</addrLine>
									<postCode>H3T 2A7</postCode>
									<settlement>Montréal</settlement>
									<country key="CA">Canada</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Branch-and-Cut Algorithm for the Dial-a-Ride Problem</title>
					</analytic>
					<monogr>
						<imprint>
							<date type="published" when="2003-10-28">October 28, 2003</date>
						</imprint>
					</monogr>
					<idno type="MD5">E13C19838221D8B72C9CD7600812A716</idno>
					<note type="submission">Submitted to Operations Research</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.8.2-SNAPSHOT" ident="GROBID" when="2025-03-14T13:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Transportation: vehicle routing</term>
					<term>Programming: cutting plane</term>
					<term>Area of review: Transportation</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>In the dial-a-ride problem, users formulate requests for transportation from a specific origin to a specific destination. Transportation is carried out by vehicles providing a shared service. The problem consists of designing a set of minimum cost vehicle routes satisfying capacity, duration, time window, pairing, precedence and ride time constraints. This paper introduces a mixed-integer programming formulation of the problem and a branch-and-cut algorithm. The algorithm uses new valid inequalities for the dial-a-ride problem as well as known valid inequalities for the pickup and delivery and the vehicle routing problems. Computational experiments performed on randomly generated instances show that the proposed approach can be used to solve small to medium size instances.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>In the Dial-a-Ride Problem (DARP), users formulate requests for transportation from a specific origin (or pick-up point) to a specific destination (or drop-off point). Transportation is carried out by vehicles that provide a shared service in the sense that several users may be in a vehicle at the same time. The aim is to design a minimum-cost set of vehicle routes accommodating all requests under a number of side constraints. A common DARP application arises in door-to-door transportation services for the elderly and the disabled. In this context, users often formulate two requests per day: an outbound request from home to a destination, and an inbound request for the return trip.</p><p>Most dial-a-ride services are characterized by the presence of two conflicting objectives: minimizing operating costs and minimizing user inconvenience. Operating costs are mostly related to fleet size and distance traveled while user inconvenience is often measured in terms of deviations from desired pick-up and drop-off times and in terms of excess ride time (i.e., the difference between the actual ride time of a user and the minimum possible ride time). One way to achieve a balance between these objectives is to treat cost minimization as the primary objective and to impose service quality constraints.</p><p>As in the work of <ref type="bibr" target="#b12">Jaw et al. (1986)</ref> and <ref type="bibr">Cordeau and Laporte (2003b)</ref>, we assume here that the user specifies either a desired arrival time at destination (in the case of an outbound request) or a desired departure time from the origin (in the case of an inbound request). In both cases, a time window of a pre-specified width is constructed around the desired time. In addition, an upper bound is imposed on the ride time of the user. This approach seems to be in line with the current practice of several North-American transporters. For example, in a system with 15-minute time windows and a maximum ride time of 60 minutes, a user wishing to arrive at destination at 9h00 would be picked-up no earlier than 7h45 and dropped-off between 8h45 and 9h00. It should be emphasized that imposing time windows is not sufficient to accurately impose a maximum ride time. In the above example, a pick-up at 7h45 and a drop-off at 9h would exceed the maximum ride time of 60 minutes. However, constraining the pick-up to take place no earlier than 8h would be too restrictive because it would, in particular, prohibit a pick-up at 7h45 and a drop-off at 8h45. Dial-a-ride services may operate according to a static or to a dynamic mode. In the first case, all requests are known beforehand while in the second case requests are gradually received throughout the day and vehicle routes are adjusted in real-time to meet demand. In practice, pure dynamic problems rarely exist since a large subset of requests is often known in advance. This paper deals with the static variant of the problem.</p><p>Because it incorporates time windows and maximum ride time constraints, the DARP is a difficult problem that generalizes the Vehicle Routing Problem with Pick-up and Delivery (VRPPD). Finding a feasible solution for the DARP is itself NP-hard since it also generalizes the Traveling Salesman Problem with Time Windows (TSPTW) (see, e.g., <ref type="bibr" target="#b21">Savelsbergh, 1985)</ref>. As a result most previous work has concentrated on the development of heuristics. Nevertheless, when the problem is moderately constrained, exact solution approaches can be devised to solve small to medium size instances.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Formulation</head><p>Let n denote the number of users (or requests) to be served. The DARP may be defined on a complete directed graph G = (N, A) where N = P ∪ D ∪ {0, 2n + 1}, P = {1, . . . , n} and D = {n + 1, . . . , 2n}. Subsets P and D contain pick-up and drop-off nodes, respectively, while nodes 0 and 2n + 1 represent the origin and destination depots. With each user i are thus associated an origin node i and a destination node n + i. Let K be the set of vehicles. Each vehicle k ∈ K has a capacity Q k and the total duration of its route cannot exceed T k . With each node i ∈ N are associated a load q i and a non-negative service duration d i such that q 0 = q 2n+1 = 0, q i = -q n+i (i = 1, . . . , n) and d 0 = d 2n+1 = 0. A time window [e i , l i ] is also associated with node i ∈ N where e i and l i represent the earliest and latest time, respectively, at which service may begin at node i. With each arc (i, j) ∈ A are associated a routing cost c ij and a travel time t ij . Finally, denote by L the maximum ride time of a user.</p><p>For each arc (i, j) ∈ A and each vehicle k ∈ K, let x k ij = 1 if vehicle k travels from node i to node j. For each node i ∈ N and each vehicle k ∈ K, let B k i be the time at which vehicle k begins service at node i, and Q k i be the load of vehicle k after visiting node i. Finally, for each user i, let L k i be the ride time of user i on vehicle k. The formulation is as follows:</p><p>Min</p><formula xml:id="formula_0">k∈K i∈N j∈N c k ij x k ij (1) subject to k∈K j∈N x k ij = 1 ∀i ∈ P (2) j∈N x k ij - j∈N x k n+i,j = 0 ∀i ∈ P, k ∈ K (3) j∈N x k 0j = 1 ∀k ∈ K (4) j∈N x k ji - j∈N x k ij = 0 ∀i ∈ P ∪ D, k ∈ K (5) i∈N x k i,2n+1 = 1 ∀k ∈ K (6) B k j ≥ (B k i + d i + t ij )x k ij ∀i ∈ N, j ∈ N, k ∈ K (7) Q k j ≥ (Q k i + q j )x k ij ∀i ∈ N, j ∈ N, k ∈ K (8) L k i = B k n+i -(B k i + d i ) ∀i ∈ P, k ∈ K (9) B k 2n+1 -B k 0 ≤ T k ∀k ∈ K (10) e i ≤ B k i ≤ l i ∀i ∈ N, k ∈ K (11) t i,n+i ≤ L k i ≤ L ∀i ∈ P, k ∈ K (12) max{0, q i } ≤ Q k i ≤ min{Q k , Q k + q i } ∀i ∈ N, k ∈ K (13) x k ij ∈ {0, 1} ∀i ∈ N, j ∈ N, k ∈ K. (<label>14</label></formula><formula xml:id="formula_1">)</formula><p>The objective function (1) minimizes the total routing cost. Constraints (2) and (3) ensure that each request is served exactly once and that the origin and destination nodes are visited by the same vehicle. Constraints (4)-( <ref type="formula">6</ref>) guarantee that the route of each vehicle k starts at the origin depot and ends at the destination depot. Consistence of the time and load variables is ensured by constraints ( <ref type="formula">7</ref>) and (8). Equalities (9) define the ride time of each user which is bounded by constraints (12). It is worth mentioning that the latter also act as precedence constraints because the non-negativity of the L k i variables ensures that node i will be visited before node n + i for every user i. Finally, inequalities (10) bound the duration of each route while ( <ref type="formula">11</ref>) and ( <ref type="formula">13</ref>) impose time windows and capacity constraints, respectively. This formulation is non-linear because of constraints ( <ref type="formula">7</ref>) and ( <ref type="formula">8</ref>). Introducing constants M k ij and W k ij , these constraints can, however, be linearized as follows:</p><formula xml:id="formula_2">B k j ≥ B k i + d i + t ij -M k ij (1 -x k ij ) ∀i ∈ N, j ∈ N, k ∈ K (15) Q k j ≥ Q k i + q j -W k ij (1 -x k ij ) ∀i ∈ N, j ∈ N, k ∈ K. (<label>16</label></formula><formula xml:id="formula_3">)</formula><p>The validity of these constraints is ensured by setting</p><formula xml:id="formula_4">M k ij ≥ max{0, l i + d i + t ij -e j } and W k ij ≥ min{Q k , Q k + q i }.</formula><p>These constraints are very similar to the Miller-Tucker-Zemlin subtour elimination constraints for the TSP <ref type="bibr" target="#b15">(Miller et al., 1960)</ref>.</p><p>One can reduce the number of variables and constraints in model ( <ref type="formula">1</ref>)-( <ref type="formula" target="#formula_0">14</ref>) by using aggregate time variables B i at every node except the origin depot 0 and the destination depot 2n + 1. In this case, one replaces ( <ref type="formula">7</ref>) and ( <ref type="formula">9</ref>) with the constraints</p><formula xml:id="formula_5">B j ≥ (B k 0 + d 0 + t 0j )x k 0j ∀j ∈ N, k ∈ K (17) B j ≥ (B i + d i + t ij ) k∈K x k ij ∀i ∈ N, j ∈ N (18) B k 2n+1 ≥ (B i + d i + t i,2n+1 )x k i,2n+1 ∀i ∈ N, k ∈ K (19) L i = B n+i -(B i + d i ) ∀i ∈ P,<label>(20)</label></formula><p>to which the same linearization process can be applied. Along the same lines, if the fleet of vehicles is homogeneous in the sense that Q k = Q for every k ∈ K, one can replace (8) with</p><formula xml:id="formula_6">Q j ≥ (Q k 0 + q j )x k 0j ∀j ∈ N, k ∈ K (21) Q j ≥ (Q i + q j ) k∈K x k ij ∀i ∈ N, j ∈ N (22) Q k 2n+1 ≥ (Q i + q 2n+1 )x k i,2n+1 ∀i ∈ N, k ∈ K. (<label>23</label></formula><formula xml:id="formula_7">)</formula><p>Finally, as shown by <ref type="bibr" target="#b6">Desrochers and Laporte (1991)</ref>, the linearized form of constraints ( <ref type="formula">22</ref>) can be lifted as follows by taking the reverse arc (j, i) into account:</p><formula xml:id="formula_8">Q j ≥ Q i + q j -W ij (1 - k∈K x k ij ) + (W ij -q i -q j ) k∈K x k ji ∀i ∈ N, j ∈ N, k ∈ K. (24)</formula><p>Observe that in our case an equivalent lifting cannot be performed with constraints (18) because waiting will sometimes take place after the beginning of a time window (i.e., B i &gt; e i ) in order to reduce the ride time of a user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Valid Inequalities</head><p>We now describe several families of valid inequalities for the DARP. All of these inequalities are of course redundant for model (1)-( <ref type="formula" target="#formula_0">14</ref>) but can strengthen its LP-relaxation. Because of the structure of the model, analyzing whether these inequalities define facets of the DARP polytope appears to be a rather challenging task. However, their usefulness is demonstrated through computational experiments in the last section.</p><p>The following additional notation will be used to describe the valid inequalities. Given a node set S ⊆ N, define δ(S) = δ + (S) ∪ δ -(S) where δ + (S) = {(i, j) ∈ A|i ∈ S, j ∈ S} and δ -(S) = {(i, j) ∈ A|i ∈ S, j ∈ S}. For notational convenience, let x ij = k∈K x k ij denote the total flow on arc (i, j) and define x(S) = i,j∈S x ij . Similarly, let x(A ′ ) = (i,j)∈A ′ x ij for any arc set A ′ ⊆ A.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Bounds on time and load variables</head><p>As first suggested by <ref type="bibr" target="#b6">Desrochers and Laporte (1991)</ref> in the context of the TSP with time windows, bounds on the time variables B i can be strengthened as follows:</p><formula xml:id="formula_9">B i ≥ e i + j∈N \{i} max{0, e j -e i + d j + t ij }x ji<label>(25)</label></formula><formula xml:id="formula_10">B i ≤ l i - j∈N \{i} max{0, l i -l j + d i + t ij }x ij .<label>(26)</label></formula><p>These inequalities were used, for example, for solving the Asymmetric Travelling Salesman Problem with Time Windows by branch-and-cut <ref type="bibr" target="#b0">(Ascheuer et al., 2001)</ref>.</p><p>Similarly, bounds on load variables Q i can also be strengthened as follows:</p><formula xml:id="formula_11">Q i ≥ max{0, q i } + j∈N \{i} max{0, q j }x ji (27) Q i ≤ min{Q, Q + q i } -(Q -max j∈N \{i} {q j } -q i )x 0i - j∈N \{i} max{0, q j }x ij . (<label>28</label></formula><formula xml:id="formula_12">)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Subtour elimination constraints</head><p>Consider the simple subtour elimination constraint x(S) ≤ |S| -1 for S ⊆ P ∪ D. In the case of the DARP, this inequality can be lifted in two different ways by taking into account the fact that for each user i, node i must be visited before node n + i.</p><p>Proposition 1. Let S ⊆ P ∪ D and P + (S) = {i|i ∈ S ∩ P and n + i ∈ S}. The following inequality is valid for the DARP:</p><p>x(S)</p><formula xml:id="formula_13">+ i∈P + (S) j∈S x n+i,j ≤ |S| -1. (<label>29</label></formula><formula xml:id="formula_14">)</formula><p>Proof. Because of precedence relationships, set S must be entered at least once before using any of the lifted arcs. As a result, x(δ -(S)) ≥ 1 + i∈P + (S) j∈S x n+i,j . In addition, x(δ + (S)) = x(δ -(S)) implies that x(δ + (S)) ≥ 1 + i∈P + (S) j∈S x n+i,j . Since 2x(S) + x(δ + (S)) + x(δ -(S)) = 2|S|, one obtains 2x(S) + 2 + 2 i∈P + (S) j∈S x n+i,j ≤ 2|S| and, finally, x(S) + i∈P + (S) j∈S x n+i,j ≤ |S| -1.</p><p>Example. Consider the node set S = {i, j} ⊆ P . The resulting lifted subtour elimination constraint is x ij + x ji + x n+i,j + x n+j,i ≤ 1. This example is illustrated in Figure <ref type="figure" target="#fig_0">1</ref>. Observe that variables x n+i,i and x n+j,j need not be introduced in the lifted inequality since the corresponding arcs can be trivially removed from the graph. x(S) + i∈S j∈D -(S)</p><formula xml:id="formula_15">x ij ≤ |S| -1. (<label>30</label></formula><formula xml:id="formula_16">)</formula><p>Proof. The proof is similar to that of Proposition 1 by observing that because of precedence relationships, set S must be exited at least once after using any of the lifted arcs and thus</p><formula xml:id="formula_17">x(δ + (S)) ≥ 1 + i∈S j∈D -(S) x ij .</formula><p>Example. Consider the node set S = {n + i, n + j} ⊆ D. The resulting lifted subtour elimination constraint is x n+i,n+j + x n+j,n+i + x n+i,j + x n+j,i ≤ 1. This is illustrated in Figure <ref type="figure" target="#fig_1">2</ref>. In the case of a directed formulation, one can also lift subtour elimination constraints by taking into account the orientation of the arcs. For a set S = {i 1 , i 2 , . . . , i h } ⊆ N with h ≥ 3 nodes, <ref type="bibr" target="#b11">Grötschel and Padberg (1995)</ref> proposed the following inequalities for the asymmetric TSP:</p><formula xml:id="formula_18">h-1 j=1 x i j ,i j+1 + x i h ,i 1 + 2 h-1 j=2 x i j ,i 1 + h-1 j=3 j-1 l=2 x i j ,i l ≤ h -1 (31) h-1 j=1 x i j ,i j+1 + x i h ,i 1 + 2 h j=3 x i 1 ,i j + h j=4 j-1 l=3 x i j ,i l ≤ h -1. (<label>32</label></formula><formula xml:id="formula_19">)</formula><p>Of course, different liftings are obtained by considering different orderings of the nodes in set S. In the case of the DARP, these inequalities can be further lifted by taking precedence relationships into account. This results in the following two propositions.</p><formula xml:id="formula_20">Proposition 3. Let S = {i 1 , i 2 , . . . , i h } ⊆ P ∪ D and P + (S) = {i|i ∈ S ∩ P and n + i ∈ S}.</formula><p>The following inequality is valid for the DARP:</p><formula xml:id="formula_21">h-1 j=1 x i j ,i j+1 + x i h ,i 1 + 2 h-1 j=2 x i j ,i 1 + h-1 j=3 j-1 l=2 x i j ,i l + ip∈P + (S) x n+ip,i 1 ≤ h -1. (<label>33</label></formula><formula xml:id="formula_22">)</formula><p>Proof. Suppose that one arc of the form (n + i p , i 1 ) with i p ∈ P + (S) is part of the solution. Then all arcs of the form (i j , i 1 ) with 2 ≤ j ≤ h -1 cannot belong to the solution. As a result, if the left-hand side of inequality ( <ref type="formula" target="#formula_21">33</ref>) is larger than h -1, then there exists a subpath linking the h nodes in set S. But because set S contains the origin node i p , this subpath together with the arc (n + i p , i 1 ) would violate the precedence constraint for user i p .</p><p>Example. Consider the node set S = {i, j, k} ⊆ P . One possible lifted directed subtour elimination constraint (obtained with</p><formula xml:id="formula_23">i 1 = i, i 2 = j, i 3 = k) is x ij + x jk + x ki + 2x ji + x n+j,i + x n+k,i ≤ 2. This is illustrated in Figure 3. n+j i j k n+k 2 Figure 3: Lifted directed subtour elimination constraint for S = {i, j, k} ⊆ P Proposition 4. Let S = {i 1 , i 2 , . . . , i h } ⊆ P ∪ D and D -(S) = {i|n + i ∈ S ∩ D and i ∈ S}.</formula><p>The following inequality is valid for the DARP:</p><formula xml:id="formula_24">h-1 j=1 x i j ,i j+1 + x i h ,i 1 + 2 h j=3 x i 1 ,i j + h j=4 j-1 l=3 x i j ,i l + ip∈D -(S) x i 1 ,ip ≤ h -1. (<label>34</label></formula><formula xml:id="formula_25">)</formula><p>Proof. The proof is similar to that of Proposition 3 by observing that if one arc of the form (i 1 , i p ) with i p ∈ D -(S) is part of the solution, then all arcs of the form (i 1 , i j ) with 3 ≤ j ≤ h cannot belong to the solution.</p><p>Example. Consider the node set S = {n + i, n + j, n + k} ⊆ D. One possible lifted directed subtour elimination constraint (obtained with </p><formula xml:id="formula_26">i 1 = n + i, i 2 = n + j, i 3 = n + k) is x n+i,n+j + x n+j,n+k + x n+k,n+i + 2x n+i,n+k + x n+i,j + x n+i,k ≤ 2. This is illustrated in Figure 4.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Capacity constraints</head><p>For any subset S ⊆ P ∪D, let R(S) denote the minimum number of vehicles needed to visit all nodes in S. The constraint x(δ(S)) ≥ 2R(S) is then a valid inequality. Although computing R(S) is difficult, a lower approximation is provided by ⌈q(S)/Q⌉ where q(S) = i∈S q i . The resulting inequality is called a rounded capacity inequality in the context of the VRP.</p><p>While capacity inequalities play an important role in most branch-and-cut algorithms for the VRP (see, e.g., <ref type="bibr" target="#b16">Naddef and Rinaldi, 2002)</ref>, they are not likely to be very strong for the DARP because of the presence of both positive and negative q i values. In particular, q(P ∪ D) = 0 by definition and, in the absence of time windows, all nodes can be visited by the same vehicle. Useful inequalities can, however, be obtained by restricting S to be a subset of either P or D and setting q(S) = | i∈S q i |. It should be emphasized that in our context, the quantity ⌈q(S)/Q⌉ estimates the required number of vehicle passages in set S rather than the number of vehicles per se. Indeed, by leaving and entering set S more than once, the same vehicle may be able to visit all nodes in the set even though q(S) &gt; Q.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Precedence constraints</head><p>Consider a node set S such that 0 ∈ S, i ∈ S, n + i ∈ S and 2n + 1 ∈ S for at least one user i. Because node i must be visited before node n + i, x(S) ≤ |S| -2 and, equivalently, x(δ(S)) ≥ 4. The same applies to node sets S such that 0 ∈ S, i ∈ S, n + i ∈ S and 2n + 1 ∈ S for at least one user i. These inequalities, which are also valid for the DARP, were introduced by Ruland and Rodin (1997) for the pickup and delivery problem.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Generalized order constraints</head><p>Let U 1 , . . . , U m ⊂ N be mutually disjoint subsets and let i 1 , . . . , i m ∈ P be users such that 0, 2n + 1 ∈ U l and i l , n + i l+1 ∈ U l for l = 1, . . . , m (where i m+1 = i 1 ). The following inequality, introduced by Ruland and Rodin (1997), is also valid for the DARP:</p><formula xml:id="formula_27">m l=1 x(U l ) ≤ m l=1 |U l | -m -1. (<label>35</label></formula><formula xml:id="formula_28">)</formula><p>In the directed case, these inequalities can be lifted in two different ways, as shown by the following propositions.</p><p>Proposition 5. The following inequality is valid for the DARP:</p><formula xml:id="formula_29">m l=1 x(U l ) + m-1 l=2 x i 1 ,i l + m l=3 x i 1 ,n+i l ≤ m l=1 |U l | -m -1. (<label>36</label></formula><formula xml:id="formula_30">)</formula><p>Proof. First observe that in any feasible integer solution, at most one of the lifted arcs may be part of the solution since they all belong to δ + (i 1 ). To demonstrate the validity of the lifting, we show that if any of the lifted arcs is part of the solution then there are at least two subsets U l for which x(U l ) ≤ |U l | -2. Since x(U l ) ≤ |U l | -1 for all other subsets, the validity of the inequality follows directly. The details of the proof are given in the appendix.</p><p>Remark 1. The numbering of the sets U 1 , . . . , U m is arbitrary and leads, by symmetry, to m! possibly different liftings.</p><p>Example. Consider the subsets U 1 = {i, n + j}, U 2 = {j, n + k} and U 3 = {k, n + i} with i 1 = i, i 2 = j and i 3 = k. The lifted generalized order constraint is x i,n+j + x n+j,i + x j,n+k + x n+k,j + x k,n+i + x n+i,k + x ij + x i,n+k ≤ 2. This is illustrated in Figure <ref type="figure" target="#fig_3">5</ref>. </p><formula xml:id="formula_31">m l=1 x(U l ) + m-2 l=2 x n+i 1 ,i l + m-1 l=2 x n+i 1 ,n+i l ≤ m l=1 |U l | -m -1. (<label>37</label></formula><formula xml:id="formula_32">)</formula><p>Proof. The reasoning is similar to that of Proposition 5 and the details of the proof are given in the appendix.</p><p>Example. Consider the subsets U 1 = {i, n + j}, U 2 = {j, n + k} and U 3 = {k, n + i} with i 1 = i, i 2 = j and i 3 = k. The lifted generalized order constraint is x i,n+j + x n+j,i + x j,n+k + x n+k,j + x k,n+i + x n+i,k + x n+i,n+j ≤ 2. This is illustrated in Figure <ref type="figure" target="#fig_4">6</ref>. Observe that in inequality (37), the value of m must be larger than or equal to 4 for the second term of the inequality to have any effect. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Order matching constraints</head><p>Consider two nodes i, j ∈ P and a subset H such that {i, j} ⊆ H ⊆ N \{0, n+i, n+j, 2n+1}.</p><p>The following inequality, introduced by Ruland and Rodin (1997), is also valid for the DARP:</p><formula xml:id="formula_33">x(H) + x({i, n + i}) + x({j, n + j}) ≤ |H|. (<label>38</label></formula><formula xml:id="formula_34">)</formula><p>As suggested by <ref type="bibr" target="#b19">Ruland (1995)</ref>, this inequality can be lifted by introducing the term x({h, n + h}) for every user h such that h ∈ H and n + h ∈ H. In the directed case, order matching constraints are in fact redundant because any arc of the form (n + h, h) can be removed from the graph. As a result, all arcs in the left-hand side of (38) have their origin node in set H. Hence, the sum of the flows on these arcs cannot exceed |H|, even in a fractional solution.</p><p>Order matching constraints can, however, be generalized by replacing the arcs (h, n + h) by node sets. This leads to the following proposition.</p><p>Proposition 7. Let i 1 , . . . , i m be m users and let H ⊂ P ∪ D and T h ⊂ P ∪ D, h = 1, . . . , m be node sets such that {i h , n</p><formula xml:id="formula_35">+ i h } ⊆ T h and H ∩ T h = {i h }.</formula><p>The following inequality is valid for the DARP:</p><formula xml:id="formula_36">x(H) + m h=1 x(T h ) ≤ |H| + m h=1 |T h | -2m. (<label>39</label></formula><formula xml:id="formula_37">)</formula><p>Proof. First observe that x(H) ≤ |H| -1 and</p><formula xml:id="formula_38">x(T h ) ≤ |T h | -1 for h = 1, . . . , m. If x(T h ) = |T h | -1</formula><p>for any given subset T h , then there exists a path connecting all nodes in T h , including i h and n+i h . However, this path cannot finish at node i h because of the precedence constraint for user i h . Let α be the number of sets T h for which</p><formula xml:id="formula_39">x(T h ) = |T h | -1. Then, x(δ + (H)) ≥ α. Since x(δ + (H)) = x(δ -(H)) and 2x(H) + x(δ + (H)) + x(δ -(H)) = 2|H|, one obtains that 2x(H) ≤ 2|H| -2α and thus x(H) ≤ |H| -α. Finally, because x(T h ) ≤ |T h | -2</formula><p>for the remaining m -α sets, one may conclude that x(H)</p><formula xml:id="formula_40">+ m h=1 x(T h ) ≤ |H| -α + m h=1 (|T h | -1) -(m -α)</formula><p>, which simplifies to expression (39). Example. Consider the sets H = {i, j}, T 1 = {i, n + i, k} and T 2 = {j, n + j, l} with i 1 = i and i 2 = j. The resulting inequality is x(H)+x(T 1 )+x(T 2 ) ≤ 4 and is illustrated in Figure <ref type="figure" target="#fig_5">7</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Infeasible path inequalities</head><p>Ride time constraints may give rise to paths that are infeasible in an integer solution but nonetheless feasible in a fractional solution. Forbidding such paths can be accomplished through the valid inequality introduced in the next proposition.</p><p>Proposition 8. For any directed path</p><formula xml:id="formula_41">P = {i, k 1 , k 2 , . . . , k p , n + i} such that t i,k 1 + d k 1 + t k 1 ,k 2 + d k 2 + • • • + t kp,n+i &gt;</formula><p>L the following inequality is valid for the DARP:</p><formula xml:id="formula_42">x i,k 1 + p-1 h=1 x k h ,k h+1 + x kp,n+i ≤ p -1. (<label>40</label></formula><formula xml:id="formula_43">)</formula><p>Proof. Suppose that the value of the left-hand side of inequality ( <ref type="formula" target="#formula_42">40</ref>) is equal to p in a feasible integer solution. Then there is a single arc from path P not belonging to the solution because the path contains p + 1 arcs. Since the solution is feasible, it must contain a path from i to n + i in which the missing arc has been replaced by at least two other arcs. But if the triangle inequality holds for travel times, the path from i to n + i has a larger duration than that of P. As a result, its duration must exceed L, which contradicts the assumption that the solution is feasible.</p><p>Remark 3. As will be shown in the next section, the case p = 1 can be handled directly through the simple elimination of arcs in a preprocessing step.</p><p>5 Branch-and-Cut Algorithm</p><p>Branch-and-cut is a popular approach for solving combinatorial problems. It has been applied successfully to several routing problems (see, e.g., <ref type="bibr" target="#b0">Ascheuer et al., 2001;</ref><ref type="bibr" target="#b10">Gendreau et al., 1998;</ref><ref type="bibr" target="#b16">Naddef and Rinaldi, 2002)</ref>. This section describes the branch-and-cut algorithm used for the DARP. It focuses on the preprocessing techniques developed to reduce problem size and on the separation heuristics used to identify violated inequalities.</p><p>After applying the preprocessing steps presented in Section 5.1, the algorithm first solves the LP relaxation of the problem. If the solution to the LP relaxation is integer, an optimal solution has been identified. Otherwise, an enumeration tree is constructed and violated valid inequalities are generated at some nodes of this tree by means of the separation heuristics described in Section 5.2.</p><p>To control the branch-and-cut process, additional variables y k i = j∈N x k ij are introduced in the formulation. At each node of the search tree, if the y k i variables are all integer in the current relaxation but there is at least one fractional x k ij variable, the separation heuristics are executed in the hope of identifying violated valid inequalities. If at least one of the heuristics succeeds in finding one or more violated inequalities, the relaxation is solved with all identified cuts and the heuristics are executed again. The cut generation process at a node terminates when all heuristics fail to find any violated inequality. If the solution to the relaxation is still fractional after the generation of cuts, branching is performed on a fractional y k i variable, if there is any, or on a fractional x k ij variable, otherwise. The variable selected for branching is that whose value is the farthest from the nearest integer.</p><p>Prior to the application of the branch-and-cut algorithm, an upper bound is computed by using the tabu search heuristic of <ref type="bibr">Cordeau and Laporte (2003b)</ref>. This upper bound is then used to prune the enumeration tree whenever the solution value at a given node exceeds that of the upper bound.</p><p>Finally, an initial set of valid inequalities is added prior to solving the initial LP relaxation: all bounds on time and load variables, lifted 2-node subtour elimination constraints, generalized order constraints with m = 2 and |U l | = 2, and precedence constraints with |S| = 3 are introduced in a pool of cuts whose violations are checked at each node of the branch-andbound tree, including those where not all y variables take integer values.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Preprocessing</head><p>This section describes the time window tightening, arc elimination and variable fixing steps that can be applied prior to the branch-and-cut algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.1">Time window tightening</head><p>Let T denote the end of the planning horizon. In the case of an outbound user, the time window at the origin node can be tightened by setting e i = max{0, e n+i -L -d i } and l i = min{l n+i -t i,n+i -d i , T }. In the case of an inbound user, the time window at the destination node can be tightened by setting e n+i = max{0, e i +d i +t i,n+i } and l n+i = min{l i +d i +L, T }.</p><p>The time window on nodes 0 and 2n + 1 can also be tightened by setting e 0 = e 2n+1 = min i∈P ∪D {e i -t 0i } and l 0 = l 2n+1 = max i∈P ∪D {l i + d i + t i,2n+1 }.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.2">Arc elimination</head><p>Formulation (1)-( <ref type="formula" target="#formula_0">14</ref>) is defined on a complete graph G. However, because of time windows, pairing and ride time constraints, several arcs can in fact be removed from the graph as they cannot belong to a feasible solution.</p><p>A simple analysis leads to the following observations:</p><p>• arcs (0, n + i), (i, 2n + 1) and (n + i, i) are infeasible for i ∈ P ;</p><formula xml:id="formula_44">• arc (i, j) with i, j ∈ N is infeasible if e i + d i + t ij &gt; l j ;</formula><p>• arcs (i, j) and (j, n + i) with i ∈ P, j ∈ N are both infeasible if t ij + d j + t j,n+i &gt; L.</p><p>As first proposed by <ref type="bibr" target="#b9">Dumas et al. (1991)</ref>, combining time windows and pairing constraints leads to even stronger elimination rules:</p><p>• arc (i, n + j) is infeasible if path P = {j, i, n + j, n + i} is infeasible;</p><p>• arc (n + i, j) is infeasible if path P = {i, n + i, j, n + j} is infeasible;</p><p>• arc (i, j) is infeasible if paths P 1 = {i, j, n + i, n + j} and P 2 = {i, j, n + j, n + i} are both infeasible;</p><p>• arc (n + i, n + j) is infeasible if paths P 1 = {i, j, n + i, n + j} and P 2 = {j, i, n + i, n + j} are both infeasible.</p><p>In the presence of ride time constraints, further elimination can be performed by identifying pairs of users that are incompatible (i.e., that cannot be assigned to the same vehicle) because of the interaction between time windows and ride time constraints. Incompatible user pairs {i, j} can be identified by checking the feasibility of the following paths: {i, j, n + i, n + j}, {i, j, n + j, n + i}, {j, i, n + i, n + j}, {j, i, n + j, n + i}, {i, n + i, j, n + j}, {j, n + j, i, n + i}.</p><p>If none of these six paths is feasible, then all eight arcs between {i, n + i} and {j, n + j} can be eliminated. Because of ride time constraints, checking the feasibility of a path is not always straightforward. In the case of the path {i, j, n + i, n + j}, for example, setting B i = e i may lead to the violation of the ride time constraint for user i in the event that unnecessary waiting time then occurs at node j. For this reason, the forward time slack should be computed at node i so as to delay the beginning of service as much as possible without violating any of the time windows. The same can be said about node j where the beginning of service should be delayed as much as possible by taking into account the additional constraint that the maximum ride time for user i should not be exceeded. In general, the forward time slack F i at node i in a path {i, i + 1, . . . , q} can be computed as follows:</p><formula xml:id="formula_45">F i = min i≤j≤q i&lt;p≤j W p + min {l j -B j , L -P j } ,<label>(41)</label></formula><p>where W i denotes the waiting time at node i, P i denotes the ride time of the user whose destination node is i if n + 1 ≤ i ≤ 2n, and P i = -∞, otherwise. This definition of the forward time slack generalizes that of <ref type="bibr" target="#b22">Savelsbergh (1992)</ref> for the TSP with time windows.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1.3">Variable fixing</head><p>The identification of incompatible user pairs can also be used to permanently assign users to specific vehicles. If the fleet of vehicles is homogeneous, one can can create a graph G ′ = (N ′ , E ′ ) where N ′ = {1, . . . , n} and E ′ contains an edge (i, j) if i and j are incompatible users. Given a clique in G ′ , each user in the clique can be assigned to a different vehicle. In addition, if user i is assigned to vehicle k, constraints can be added to the formulation so as to forbid the assignment to vehicle k of users that are incompatible with i. Finding a clique of maximum cardinality in G ′ may be very time consuming when n is large. In our implementation, we thus use a greedy heuristic described by <ref type="bibr" target="#b13">Johnson (1974)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Separation Heuristics</head><p>This section describes the separation heuristics used to identify violated inequalities. When all y k i variables are integer but there is at least one fractional x k ij variable, the following heuristics are executed sequentially.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.1">Subtour elimination constraints</head><p>The identification of violated inequalities of the form x(S) ≤ |S|-1 can be achieved by solving a series of maximum flow problems between any node i and all other nodes j ∈ N \ {i}. However, in addition to being time-consuming, this approach does not take the possible liftings into account. For these reasons, we resort to a simple tabu search heuristic inspired from that proposed by <ref type="bibr" target="#b1">Augerat et al. (1999)</ref>.</p><p>Using the fact that 2x(S) + x(δ(S)) = 2|S| in a feasible integer solution, violations of ( <ref type="formula" target="#formula_13">29</ref>) can be identified by finding node sets S such that</p><formula xml:id="formula_46">x(δ(S)) -2 i∈P + (S) j∈S x n+i,j &lt; 2. (<label>42</label></formula><formula xml:id="formula_47">)</formula><p>The heuristic starts with an empty set S. At each iteration, it either adds or removes a node from the set S so as to minimize the left-hand side of (42). Whenever a node is removed from set S, its reinsertion is declared tabu for θ iterations. The heuristic runs for a preset number of iterations (100 in our implementation) and may identify several violated inequalities during a single execution. At each iteration, the current set S is also checked for possible violations of inequality (33). To this purpose, the node with the largest outgoing flow is numbered as i 1 and the other nodes are numbered at random.</p><p>A similar heuristic is used to identify violations of inequalities ( <ref type="formula" target="#formula_15">30</ref>) and ( <ref type="formula" target="#formula_24">34</ref>). In the latter case, the node with the largest incoming flow is numbered as i 1 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.2">Capacity constraints</head><p>Again, we use a tabu search heuristic to identify sets S such that q(S) &gt; Q and x(δ(S)) &lt; 4.</p><p>The heuristic starts either with a random subset S ⊆ P or with a random subset S ⊆ D. At each iteration, a node is either removed or added to the set S so as to minimize the value of x(δ(S)), with the constraint that q(S) &gt; Q. Again, the heuristic runs for 100 iterations and multiple violated inequalities may be identified during a single execution.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.3">Precedence constraints</head><p>As explained by <ref type="bibr" target="#b19">Ruland (1995)</ref>, identifying violated precedence constraints can be done by solving a multi-terminal maximum flow problem for each user. To check whether the precedence constraint for user i is violated, one can compute the maximum flow from the sources 0 and n + i to the sinks i and 2n + 1. If the value of this flow is less than 2, then a precedence constraint x(S) ≤ |S| -2 is violated for a set S such that 0, n + i ∈ S and i, 2n + 1 ∈ S. The set S corresponds to one of the shores of the corresponding minimum cut. We have implemented this approach and use the maximum flow algorithm provided in the GTL library (see <ref type="url" target="http://infosun.fmi.uni-passau.de/GTL">http://infosun.fmi.uni-passau.de/GTL</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.4">Generalized order constraints</head><p>Ruland <ref type="bibr">(1995)</ref> proposed an approach to identify violated generalized order constraints with m = 2. This approach requires the computation of O(|N| 2 ) maximum flows. Here, we use instead three simple heuristics, the second and third of which take advantage of the lifted forms ( <ref type="formula" target="#formula_29">36</ref>) and (37).</p><p>The first heuristic attempts to identify violations of inequalities (35) for the special case where m = 2 and |U 1 | = |U 2 | = 3. For each pair of users i, j ∈ P , we first form the subsets U 1 = {i, n + j} and U 2 = {j, n + i}. We then identify nodes k 1 and k 2 such that x(U 1 ) and x(U 2 ) are maximized, and check for a violation of the resulting inequality.</p><p>The second and third heuristics are aimed at finding violations of inequalities ( <ref type="formula" target="#formula_29">36</ref>) and ( <ref type="formula" target="#formula_31">37</ref>) for the special case where m = 3 and</p><formula xml:id="formula_48">|U 1 | = |U 2 | = |U 3 | = 2.</formula><p>The second heuristic finds, for each user i, a user j that maximizes x i,n+j + x n+j,i + x ij . It then finds a user k such that the left-hand side of ( <ref type="formula" target="#formula_29">36</ref>) is maximized. Similarly, the third heuristic finds, for each user i, a user j that maximizes x i,n+j + x n+j,i + x n+i,n+j and then finds a user k that maximizes the left-hand side of (37).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.5">Order matching constraints</head><p>To identify violated order matching constraints, <ref type="bibr" target="#b19">Ruland (1995)</ref> has proposed an algorithm requiring the solution of O(|N| 2 ) maximum flow problems.</p><p>We again resort to a simpler heuristic that aims to identify violations of (39) for the special case where m = 2, |H| = 3 and |T 1 | = |T 2 | = 3. For each pair of users i, j ∈ P , we first form the subsets T 1 = {i, n + i} and T 2 = {j, n + j}. We then select the nodes k 1 and k 2 such that x(T 1 ) and x(T 2 ) are maximized. Finally, we select the node k such x(H) is maximized and check for a violation of the resulting inequality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2.6">Infeasible path inequalities</head><p>Violated path inequalities are identified by means of a path-construction heuristic applied to each user i ∈ P . The heuristic starts with node i and gradually constructs a path</p><formula xml:id="formula_49">P i = {i, k 1 , k 2 , .</formula><p>. . } by iteratively moving from the current node k j to the node k l that maximizes the value of x k j k l . The process stops if a cycle is formed or if the heuristic reaches either node n + i or node 2n + 1. If the path stops at node n + i, it is checked for a violation of inequality (40).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Computational Experiments</head><p>The branch-and-cut algorithm just described was implemented in C++ by using ILOG Concert 1.3 and CPLEX 8.1. It was run on a 2.5 GHz Pentium 4 computer with 512Mb of memory.</p><p>The algorithm was applied to two sets of randomly generated instances comprising up to 32 users. In an instance with n users, where n is even, users 1, . . . , n/2 are assumed to formulate outbound requests while users n/2 + 1, . . . , n formulate inbound requests. In all instances, the coordinates of pick-up and drop-off nodes are randomly and independently chosen in the square <ref type="bibr">[-10, 10</ref>] × [-10, 10] according to a uniform distribution, and the depot is located at the center of this square. For every arc (v i , v j ) ∈ A, the routing cost c ij and travel time t ij are equal to the Euclidean distance between the two nodes.</p><p>A time window [e i , l i ] is also associated to each node. For an outbound user i, a time window was generated by first choosing a number e n+i in the interval [420, 1080] (i.e., between 7h00 and 18h00) and then setting l n+i = e n+i +15. For an inbound user, the value of e i was chosen in the interval [360, 1020] and the value of l i was set equal to e i + 15. Time windows on the origin nodes of outbound requests and on the destination nodes of inbound requests are set as explained in Section 5.1.1.</p><p>In the first set of instances, Q = 3 for every vehicle, q i = 1 for every user and the maximum ride time L is equal to 30 minutes. In the second set, Q = 6 for every vehicle and the values of q i are chosen randomly according to a uniform distribution on the set {1, . . . , Q}. The maximum ride time is set equal to 60 minutes. In all cases, we assume that service time is proportional to the number of passengers and d i = q i . The maximum route duration is set to 720 minutes. The first set of instances represents the context where cars are used for the transportation of individuals whereas the second set reflects the situation of a transporter using mini-busses for the transportation of individuals or groups of individuals.</p><p>Tables <ref type="table" target="#tab_0">1</ref> and<ref type="table" target="#tab_1">2</ref> provide the characteristics of these instances, the number of constraints and variables in the resulting integer programming formulation, the value of the LP relaxation and the cost of a heuristic solution. This solution was obtained by running the tabu search algorithm of <ref type="bibr">Cordeau and Laporte (2003b)</ref> for 1000 iterations.</p><p>In Tables <ref type="table" target="#tab_2">3</ref> and<ref type="table" target="#tab_3">4</ref> we indicate the best lower bounds reached by running the branch-andcut algorithm on each instance with a maximum CPU time limit of 60 minutes. Column CPLEX indicates the bound obtained by running CPLEX itself with no user-cut generation but after the application of the preprocessing steps of Section 5.1. The next columns report the bounds obtained by generating the lifted bounds on time and load variables (Section 4.1) with only one of the following: subtour eliminations constraints (SEC), capacity constraints (CC), generalized order constraints (GOC), order matching constraints (OMC) and infeasible path constraints (IPC). Average values reported on the last line of each table show that the strength of the various inequalities varies from one set of instances to the other. Furthermore, for the first set of instances, using any kind of inequality alone did not yield significantly better bounds than using CPLEX directly, except for subtour elimination constraints. This is explained by the fact that the additional CPU time used to identify violated inequalities allows for the exploration of a reduced number of nodes in the search tree. We do not report the results for the generation of precedence constraints since these were significantly worse than the direct CPLEX implementation. Combining the different types of inequalities does, however, yield important improvements over the basic version of CPLEX. Tables <ref type="table" target="#tab_4">5</ref> and<ref type="table" target="#tab_5">6</ref> reports the results obtained by using the basic version of CPLEX and by using the five types of inequalities concurrently. In both cases, a maximum of 12 hours of CPU time was allowed for the solution of each instance. We report the best bound obtained, the CPU time used and the number of nodes explored in the branch-and-bound tree. For the branch-and-cut algorithm, we also indicate the total number of user cuts generated. An asterisk preceding a lower bound indicates that the instance was solved to optimality.</p><p>One can observe that the branch-and-cut algorithm is significantly faster than using CPLEX alone. For the 19 instances solved to optimality by both approaches within the time limit, the average CPU time was 118.60 minutes for CPLEX compared with 33.02 minutes for the branch-and-cut algorithm. The average number of nodes explored went down from 351,623 to 61,584. For the eight instances that could not be solved optimally by any of the two approaches, the average lower bound reached by CPLEX was 377.12 compared with 393.36 for the branch-and-cut algorithm. Finally, the branch-and-cut algorithm solved three more instances to optimality.</p><p>The small number of cuts generated with respect to the number of nodes explored in the branch-and-bound tree is explained by the fact that the separation procedures are executed only when all y k i variables are integer. For most instances, this occurs at approximately 5% of the nodes. Experiments performed with the generation of cuts at every node of the tree have produced slightly worse results because of the extra time spent by the separation procedures. It is likely that a larger number of cuts could be generated by using exact or more sophisticated heuristic separation procedures. The development of such procedures is by itself an important area of research that will be addressed in future work. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>We have introduced several new valid inequalities and a branch-and-cut algorithm for the dial-a-ride problem. Although no polyhedral analysis was carried out, the usefulness of these inequalities has been demonstrated through computational experiments. A comparison with version 8.1 of CPLEX shows that the branch-and-cut algorithm proposed here reduces both the CPU time and the number of nodes explored in the branch-and-bound tree. The methodology proposed in this paper obviously cannot be used to solve large-scale instances containing hundreds or thousands of users as it is sometimes the case in large cities. It is, however, fast enough to be used as a post-processor to optimize individual routes or small subsets of routes produced by a meta-heuristic. In the presence of ride time constraints, using dynamic programming would be difficult since the states of the dynamic programming algorithm would have to take into account the individual ride time of each user. Future work will concentrate on the development of more refined separation procedures for the various types of inequalities introduced in this paper.</p><p>for U 1 must visit node n + i 2 before visiting node i 1 . In addition, this path must appear immediately before the arc (i 1 , n + i l ) in the solution. Now, for k = 2, . . . , l -1, the path for U k must appear before that for U k-1 in the solution to avoid violating the precedence constraint for user i k . But for k = l -1, this implies that node n + i l appears before node i 1 , which is a contradiction since the arc (i 1 , n + i l ) is part of the solution.</p><p>Next, we show that for there is at least one subset U k with l ≤ k ≤ m for which x(U k ) ≤ |U k | -2. Suppose this is not true. Since the arc (i 1 , n + i l ) is in the solution, then for k = l, . . . , m, the path for U k must appear before the arc (i 1 , n + i l ) in the solution to avoid violating the precedence constraint for user i k . But for k = m, this implies that the path connecting i m and n + i 1 appears before node i 1 , which is a contradiction.</p><p>Details of the proof of Proposition 6.</p><p>Again, there are two cases to distinguish.</p><p>Case 1. An arc (n + i 1 , i l ) with 2 ≤ l ≤ m -2 is part of the solution.</p><p>For k = l -1, . . . , 1, the path connecting i k and n + i k+1 must appear after the arc (n + i 1 , i l ) in the solution to avoid violating the precedence constraint for user i k+1 . But for k = 1 this implies that the path connecting i 1 and n + i 2 appears after the arc (n + i 1 , i l ), which is a contradiction.</p><p>Since the arc (n+ i 1 , i l ) is in the solution, the subpath for U l must visit node i l before visiting node n + i l+1 . For k = l + 1, . . . , m, the path for U k must appear before that for U k-1 to avoid violating the precedence constraint for user i k . But for k = m, this implies that the path connecting i m and n + i 1 appears before the path for at least one other subset U h with l + 1 ≤ h ≤ m -1, and thus node n + i 1 appears in two different places in the solution.</p><p>Case 2. An arc (n + i 1 , n + i l ) with 2 ≤ l ≤ m -1 is part of the solution.</p><p>For k = 1, . . . , l-1, the path connecting i k and n+i k+1 must appear after the arc (n+i 1 , n+i l ). But for k = 1, this implies that node i 1 appears after node n + i 1 , which is a contradiction.</p><p>The path for U l must appear before the arc (n + i 1 , n + i L ) and, for k = l + 1, . . . , m -1, the path for U k must appear before that for U k-1 . But for k = m, this implies that the path connecting i m and n + i 1 appears before the path for at least one other subset U h with l ≤ h ≤ m -1, and thus node n + i 1 appears in two different places in the solution.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Figure 1: Lifted subtour elimination constraint for S = {i, j} ⊆ P</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Figure 2: Lifted subtour elimination constraint for S = {n + i, n + j} ⊆ D</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>Figure 4: Lifted directed subtour elimination constraint for S = {n + i, n + j, n + k} ⊆ D</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Figure 5: Lifted generalized order constraint with m = 3 (first lifting)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Figure 6: Lifted generalized order constraint with m = 3 (second lifting)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 :</head><label>7</label><figDesc>Figure 7: Generalized order matching constraint with m = 2</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Characteristics of the first set of instances</figDesc><table><row><cell cols="2">Instance m n Q L Cons Vars</cell><cell>LP</cell><cell>Heuristic</cell></row><row><cell>p2-16</cell><cell cols="3">2 16 3 30 855 733 270.25 298.00</cell></row><row><cell>p2-20</cell><cell cols="3">2 20 3 30 1134 1050 300.55 345.14</cell></row><row><cell>p2-24</cell><cell cols="3">2 24 3 30 1895 1679 304.10 375.15</cell></row><row><cell>p2-28</cell><cell cols="3">2 28 3 30 2610 2344 337.60 417.12</cell></row><row><cell>p2-32</cell><cell cols="3">2 32 3 30 3536 3098 350.15 466.53</cell></row><row><cell>p3-16</cell><cell cols="3">3 16 3 30 920 1020 197.39 258.10</cell></row><row><cell>p3-20</cell><cell cols="3">3 20 3 30 1520 1776 238.88 282.81</cell></row><row><cell>p3-24</cell><cell cols="3">3 24 3 30 1957 2311 312.90 374.18</cell></row><row><cell>p3-28</cell><cell cols="3">3 28 3 30 2609 3059 368.43 478.58</cell></row><row><cell>p3-32</cell><cell cols="3">3 32 3 30 3676 4593 291.22 423.08</cell></row><row><cell>p4-16</cell><cell cols="3">4 16 3 30 960 1299 229.12 294.82</cell></row><row><cell>p4-20</cell><cell cols="3">4 20 3 30 1502 2104 256.25 343.37</cell></row><row><cell>p4-24</cell><cell cols="3">4 24 3 30 2171 3188 254.20 334.41</cell></row><row><cell>p4-28</cell><cell cols="3">4 28 3 30 2911 4479 267.28 395.90</cell></row><row><cell>p4-32</cell><cell cols="3">4 32 3 30 3575 5564 376.65 491.82</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Characteristics of the second set of instances</figDesc><table><row><cell cols="2">Instance m n Q L Cons Vars</cell><cell>LP</cell><cell>Heuristic</cell></row><row><cell>g2-16</cell><cell cols="3">2 16 6 60 666 600 223.14 269.98</cell></row><row><cell>g2-20</cell><cell cols="3">2 20 6 60 1232 1176 280.41 374.77</cell></row><row><cell>g2-24</cell><cell cols="3">2 24 6 60 1379 9379 307.64 429.90</cell></row><row><cell>g2-28</cell><cell cols="3">2 28 6 60 2448 2163 336.35 427.06</cell></row><row><cell>g2-32</cell><cell cols="3">2 32 6 60 2747 2395 400.81 544.95</cell></row><row><cell>g3-16</cell><cell cols="3">3 16 6 60 782 917 207.28 256.70</cell></row><row><cell>g3-20</cell><cell cols="3">3 20 6 60 1200 1459 251.37 301.41</cell></row><row><cell>g3-24</cell><cell cols="3">3 24 6 60 1796 2045 319.89 449.88</cell></row><row><cell>g3-28</cell><cell cols="3">3 28 6 60 2401 2807 325.37 451.09</cell></row><row><cell>g3-32</cell><cell cols="3">3 32 6 60 2625 3293 391.38 562.73</cell></row><row><cell>g4-16</cell><cell cols="3">4 16 6 60 875 1220 217.09 273.60</cell></row><row><cell>g4-20</cell><cell cols="3">4 20 6 60 1146 1642 257.69 363.75</cell></row><row><cell>g4-24</cell><cell cols="3">4 24 6 60 1753 2639 300.70 423.10</cell></row><row><cell>g4-28</cell><cell cols="3">4 28 6 60 2484 3399 261.27 363.70</cell></row><row><cell>g4-32</cell><cell cols="3">4 32 6 60 2880 4221 351.21 516.00</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Best lower bounds -first set of instances</figDesc><table><row><cell cols="2">Instance CPLEX SEC</cell><cell>CC</cell><cell>GOC OMC</cell><cell>IPC</cell></row><row><cell>p2-16</cell><cell cols="4">298.00 298.00 298.00 298.00 298.00 298.00</cell></row><row><cell>p2-20</cell><cell cols="4">345.14 345.14 345.14 245.14 345.14 345.14</cell></row><row><cell>p2-24</cell><cell cols="4">375.15 375.15 375.15 375.15 375.15 375.15</cell></row><row><cell>p2-28</cell><cell cols="4">403.92 417.05 402.75 417.05 410.24 405.66</cell></row><row><cell>p2-32</cell><cell cols="4">426.62 441.46 426.31 427.54 427.73 430.53</cell></row><row><cell>p3-16</cell><cell cols="4">258.10 258.10 258.10 258.10 258.10 258.10</cell></row><row><cell>p3-20</cell><cell cols="4">282.81 282.81 282.81 282.81 282.81 282.81</cell></row><row><cell>p3-24</cell><cell cols="4">374.07 374.07 374.07 374.07 374.07 374.07</cell></row><row><cell>p3-28</cell><cell cols="4">440.69 448.35 433.47 442.73 432.49 442.31</cell></row><row><cell>p3-32</cell><cell cols="4">343.03 337.49 333.87 333.60 335.11 331.88</cell></row><row><cell>p4-16</cell><cell cols="4">294.82 294.82 294.82 294.82 294.82 294.82</cell></row><row><cell>p4-20</cell><cell cols="4">318.89 325.78 316.60 320.27 317.79 316.64</cell></row><row><cell>p4-24</cell><cell cols="4">291.53 292.54 293.02 295.12 291.07 294.02</cell></row><row><cell>p4-28</cell><cell cols="4">322.17 320.34 317.51 318.47 320.13 318.99</cell></row><row><cell>p4-32</cell><cell cols="4">399.74 401.34 401.76 400.73 401.92 402.00</cell></row><row><cell>Avg.</cell><cell cols="4">344.98 347.50 343.56 338.91 344.30 344.67</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head>Table 4 :</head><label>4</label><figDesc>Best lower bounds -second set of instances</figDesc><table><row><cell cols="2">Instance CPLEX SEC</cell><cell>CC</cell><cell>GOC OMC</cell><cell>IPC</cell></row><row><cell>g2-16</cell><cell cols="4">268.36 268.36 268.36 268.36 268.36 268.36</cell></row><row><cell>g2-20</cell><cell cols="4">370.77 370.77 370.77 370.77 370.77 370.77</cell></row><row><cell>g2-24</cell><cell cols="4">397.60 429.27 426.05 429.27 415.52 413.46</cell></row><row><cell>g2-28</cell><cell cols="4">409.30 418.95 424.27 416.53 418.02 417.29</cell></row><row><cell>g2-32</cell><cell cols="4">502.84 528.20 523.01 516.85 508.62 510.84</cell></row><row><cell>g3-16</cell><cell cols="4">255.18 255.18 255.18 255.18 255.18 255.18</cell></row><row><cell>g3-20</cell><cell cols="4">300.45 300.45 300.45 300.45 300.45 300.45</cell></row><row><cell>g3-24</cell><cell cols="4">382.67 402.90 411.80 399.11 395.84 393.96</cell></row><row><cell>g3-28</cell><cell cols="4">375.30 383.36 382.60 381.95 377.08 382.27</cell></row><row><cell>g3-32</cell><cell cols="4">443.54 453.94 462.18 456.98 452.35 451.84</cell></row><row><cell>g4-16</cell><cell cols="4">270.24 270.24 270.24 270.24 270.24 270.24</cell></row><row><cell>g4-20</cell><cell cols="4">346.42 361.56 361.56 361.35 361.56 361.56</cell></row><row><cell>g4-24</cell><cell cols="4">349.38 360.96 359.82 357.07 358.03 356.16</cell></row><row><cell>g4-28</cell><cell cols="4">285.90 293.76 295.17 295.42 291.11 294.37</cell></row><row><cell>g4-32</cell><cell cols="4">390.11 405.24 414.47 411.68 406.33 405.04</cell></row><row><cell>Avg.</cell><cell cols="4">356.54 366.88 368.40 366.08 363.30 363.45</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 5 :</head><label>5</label><figDesc>Comparisons with CPLEX -first set of instances</figDesc><table><row><cell></cell><cell></cell><cell>CPLEX</cell><cell></cell><cell></cell><cell cols="2">Branch-and-cut</cell></row><row><cell cols="3">Instance Bound CPU</cell><cell>Nodes</cell><cell cols="4">Bound CPU Nodes Cuts</cell></row><row><cell cols="2">p2-16 *298.00</cell><cell>0.01</cell><cell>54</cell><cell>*298.00</cell><cell>0.03</cell><cell>36</cell><cell>27</cell></row><row><cell cols="2">p2-20 *345.14</cell><cell>0.11</cell><cell>628</cell><cell>*345.14</cell><cell>0.12</cell><cell>160</cell><cell>77</cell></row><row><cell cols="2">p2-24 *375.15</cell><cell>5.96</cell><cell>21,844</cell><cell>*375.15</cell><cell>3.12</cell><cell cols="2">5,368 203</cell></row><row><cell cols="3">p2-28 *417.05 188.57</cell><cell>472,114</cell><cell>*417.05</cell><cell cols="3">8.59 12,516 359</cell></row><row><cell>p2-32</cell><cell cols="2">448.70 720.00</cell><cell>909,500</cell><cell cols="4">*466.53 142.51 148,501 545</cell></row><row><cell cols="2">p3-16 *258.10</cell><cell>0.05</cell><cell>288</cell><cell>*258.10</cell><cell>0.07</cell><cell>218</cell><cell>36</cell></row><row><cell cols="2">p3-20 *282.81</cell><cell>1.37</cell><cell>5,118</cell><cell>*282.81</cell><cell>1.33</cell><cell>3,420</cell><cell>85</cell></row><row><cell cols="2">p3-24 *374.07</cell><cell>2.04</cell><cell>6,042</cell><cell>*374.07</cell><cell>1.12</cell><cell cols="2">1,785 108</cell></row><row><cell cols="3">p3-28 *462.80 379.36</cell><cell>802,594</cell><cell cols="4">*462.80 153.56 240,402 269</cell></row><row><cell>p3-32</cell><cell cols="2">354.45 720.00</cell><cell>446,400</cell><cell cols="4">354.71 720.00 377,030 802</cell></row><row><cell cols="2">p4-16 *294.82</cell><cell>3.45</cell><cell>22,233</cell><cell>*294.82</cell><cell>1.35</cell><cell>5,764</cell><cell>74</cell></row><row><cell cols="4">p4-20 *341.93 524.59 1,403,353</cell><cell cols="4">*341.93 308.97 765,146 181</cell></row><row><cell>p4-24</cell><cell cols="2">309.73 720.00</cell><cell>711,000</cell><cell cols="4">*332.96 685.54 451,915 1203</cell></row><row><cell>p4-28</cell><cell cols="2">337.34 720.00</cell><cell>584,900</cell><cell cols="4">341.00 720.00 433,158 390</cell></row><row><cell>p4-32</cell><cell cols="2">412.11 720.00</cell><cell>263,100</cell><cell cols="4">418.71 720.00 267,975 471</cell></row></table></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head>Table 6 :</head><label>6</label><figDesc>Comparisons with CPLEX -second set of instances</figDesc><table><row><cell></cell><cell></cell><cell>CPLEX</cell><cell></cell><cell></cell><cell cols="2">Branch-and-cut</cell></row><row><cell cols="3">Instance Bound CPU</cell><cell>Nodes</cell><cell cols="3">Bound CPU Nodes Cuts</cell></row><row><cell cols="2">g2-16 *268.36</cell><cell>0.05</cell><cell>483</cell><cell>*268.36</cell><cell>0.08</cell><cell>200 118</cell></row><row><cell cols="2">g2-20 *370.77</cell><cell>6.95</cell><cell>50,483</cell><cell>*370.77</cell><cell>4.57</cell><cell>6,170 880</cell></row><row><cell cols="3">g2-24 *429.27 157.16</cell><cell>777,836</cell><cell cols="3">*429.27 27.18 36,220 871</cell></row><row><cell cols="3">g2-28 *424.27 215.48</cell><cell>557,624</cell><cell cols="3">*424.27 86.65 40,925 1973</cell></row><row><cell cols="4">g2-32 *544.86 577.92 1,777,740</cell><cell cols="3">*544.86 18.48 20,775 727</cell></row><row><cell cols="2">g3-16 *255.18</cell><cell>3.26</cell><cell>35,456</cell><cell>*255.18</cell><cell>1.07</cell><cell>4,512 156</cell></row><row><cell cols="3">g3-20 *300.45 31.70</cell><cell>133,174</cell><cell>*300.45</cell><cell>2.22</cell><cell>4,464 243</cell></row><row><cell>g3-24</cell><cell cols="3">408.43 720.00 1,356,000</cell><cell cols="3">*449.11 205.08 251,378 437</cell></row><row><cell>g3-28</cell><cell cols="2">390.48 720.00</cell><cell>839,900</cell><cell cols="3">413.00 720.00 344,902 1936</cell></row><row><cell>g3-32</cell><cell cols="2">458.96 720.00</cell><cell>505,300</cell><cell cols="3">487.33 720.00 260,305 1853</cell></row><row><cell cols="3">g4-16 *270.24 28.04</cell><cell>167,427</cell><cell>*270.24</cell><cell cols="2">3.64 12,014 167</cell></row><row><cell cols="3">g4-20 *361.56 127.42</cell><cell>446,344</cell><cell>*361,56</cell><cell>5.21</cell><cell>9,996 145</cell></row><row><cell>g4-24</cell><cell cols="2">366.52 720.00</cell><cell>929,700</cell><cell cols="3">386.89 720.00 652,610 379</cell></row><row><cell>g4-28</cell><cell cols="2">296.19 720.00</cell><cell>513,100</cell><cell cols="3">310.66 720.00 315,316 935</cell></row><row><cell>g4-32</cell><cell cols="2">400.94 720.00</cell><cell>408,600</cell><cell cols="3">434.57 720.00 201,539 1212</cell></row></table></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div><head>Acknowledgments</head><p>This work was supported by the <rs type="funder">Natural Sciences and Engineering Research Council of Canada</rs> under grant <rs type="grantNumber">227837-00</rs>. This support is gratefully acknowledged.</p></div>
			</div>
			<listOrg type="funding">
				<org type="funding" xml:id="_2A4N8TM">
					<idno type="grant-number">227837-00</idno>
				</org>
			</listOrg>
			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Appendix</head><p>Details of the proof of Proposition 5.</p><p>There are two cases to distinguish.</p><p>Case 1. An arc (i 1 , i l ) with 2 ≤ l ≤ m -1 is part of the solution.</p><p>First, we show that there is at least one subset U k with 1 ≤ k ≤ l -1 for which x(U k ) ≤ |U k | -2. Suppose this is not true. Then, for every k, there is a path in U k connecting i k and n + i k+1 . Since the arc (i 1 , i l ) is in the solution, the path for U 1 must visit node n + i 2 before visiting node i 1 . In addition, this path must appear immediately before the arc (i 1 , i l ) in the solution. Now, for k = 2, . . . , l -1, the path for U k must appear before that for U k-1 in the solution to avoid violating the precedence constraint for user i k . But for k = l -1, this implies that node n + i l appears before node i l , which is a contradiction.</p><p>Next, we show that there is at least one subset</p><p>Suppose this is not true. Then, for every k, there is a path in U k connecting i k and n + i k+1 . Since the arc (i 1 , i l ) is in the solution, the path for U l must visit node i l before visiting node n + i l+1 . In addition, this path must appear immediately after the arc (i 1 , i l ) in the solution. Now, for k = l + 1, . . . , m, the path for U k must appear before that for U k-1 in the solution to avoid violating the precedence constraint for user i k . But for k = m, this implies that node n + i 1 appears before node i 1 , which is a contradiction.</p><p>Case 2. An arc (i 1 , n + i l ) with 3 ≤ l ≤ m is part of the solution.</p><p>First, we show that there is at least one subset U k with 1 ≤ k ≤ l -1 for which x(U k ) ≤ |U k | -2. Suppose this is not true. Since the arc (i 1 , n + i l ) is in the solution, the path</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Solving the Asymmetric Travelling Salesman Problem with Time Windows by Branch-and-Cut</title>
		<author>
			<persName><forename type="first">N</forename><surname>Ascheuer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Fischetti</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Grötschel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Programming</title>
		<imprint>
			<biblScope unit="volume">90</biblScope>
			<biblScope unit="page" from="475" to="506" />
			<date type="published" when="2001">2001</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Separating Capacity Inequalities in the CVRP Using Tabu Search</title>
		<author>
			<persName><forename type="first">P</forename><surname>Augerat</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Belenguer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Benavent</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Corberán</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Naddef</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">106</biblScope>
			<biblScope unit="page" from="546" to="557" />
			<date type="published" when="1999">1999</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The Multi-Vehicle Subscriber Dial-a-Ride Problem</title>
		<author>
			<persName><forename type="first">L</forename><forename type="middle">D</forename><surname>Bodin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Sexton</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">TIMS Studies in Management Science</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="73" to="86" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The Dial-a-Ride Problem (DARP): Variants, Modeling Issues and Algorithms</title>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Cordeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Laporte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">4OR -Quarterly Journal of the Belgian, French and Italian Operations Research Societies</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="89" to="101" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Tabu Search Heuristic for the Static Multi-Vehicle Dial-a-Ride Problem</title>
		<author>
			<persName><forename type="first">J.-F</forename><surname>Cordeau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Laporte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transportation Research B</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="579" to="594" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">VRP with Pickup and Delivery</title>
		<author>
			<persName><forename type="first">G</forename><surname>Desaulniers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Desrosiers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Erdmann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">M</forename><surname>Solomon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Soumis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Vehicle Routing Problem</title>
		<title level="s">SIAM Monographs on Discrete Mathematics and Applications</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Toth</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Vigo</surname></persName>
		</editor>
		<meeting><address><addrLine>Philadelphia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="225" to="242" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Improvements and Extensions to the Miller-Tucker-Zemlin Subtour Elimination Constraints</title>
		<author>
			<persName><forename type="first">M</forename><surname>Desrochers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Laporte</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research Letters</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="27" to="36" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A Dynamic Programming Solution of the Large-Scale Single-Vehicle Dial-a-Ride Problem with Time Windows</title>
		<author>
			<persName><forename type="first">J</forename><surname>Desrosiers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Dumas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Soumis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">American Journal of Mathematical and Management Sciences</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="301" to="325" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Large Scale Multi-Vehicle Dial-a-Ride Problems</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dumas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Desrosiers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Soumis</surname></persName>
		</author>
		<idno>G-89-30</idno>
		<imprint>
			<date type="published" when="1989">1989</date>
		</imprint>
		<respStmt>
			<orgName>HEC Montréal</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">GERAD Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">The Pickup and Delivery Problem with Time Windows</title>
		<author>
			<persName><forename type="first">Y</forename><surname>Dumas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Desrosiers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Soumis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">European Journal of Operational Research</title>
		<imprint>
			<biblScope unit="volume">54</biblScope>
			<biblScope unit="page" from="7" to="22" />
			<date type="published" when="1991">1991</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Branch-and-Cut Algorithm for the Undirected Selective Traveling Salesman Problem</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gendreau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Laporte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Semet</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Networks</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="263" to="273" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Polyhedral Theory</title>
		<author>
			<persName><forename type="first">M</forename><surname>Grötschel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W</forename><surname>Padberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Traveling Salesman Problem</title>
		<editor>
			<persName><forename type="first">E</forename><forename type="middle">L</forename><surname>Lawler</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">K</forename><surname>Lenstra</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><forename type="middle">H G</forename><surname>Rinnooy Kan</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><forename type="middle">B</forename><surname>Shmoys</surname></persName>
		</editor>
		<meeting><address><addrLine>New York</addrLine></address></meeting>
		<imprint>
			<publisher>Wiley</publisher>
			<date type="published" when="1995">1995</date>
			<biblScope unit="page" from="251" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Heuristic Algorithm for the Multi-Vehicle Advance-Request Dial-a-Ride Problem with Time Windows</title>
		<author>
			<persName><forename type="first">J</forename><surname>Jaw</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">R</forename><surname>Odoni</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">N</forename><surname>Psaraftis</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><forename type="middle">H M</forename><surname>Wilson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transportation Research B</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="page" from="243" to="257" />
			<date type="published" when="1986">1986</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Approximation Algorithms for Combinatorial Optimization Problems</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer and System Sciences</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="256" to="278" />
			<date type="published" when="1974">1974</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Heuristic Algorithm for a Dial-a-Ride Problem with Time Windows, Multiple Capacities, and Multiple Objectives</title>
		<author>
			<persName><forename type="first">O</forename><forename type="middle">B G</forename><surname>Madsen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">F</forename><surname>Ravn</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">M</forename><surname>Rygaard</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Operations Research</title>
		<imprint>
			<biblScope unit="volume">60</biblScope>
			<biblScope unit="page" from="193" to="208" />
			<date type="published" when="1995">1995</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Integer Programming Formulations and Traveling Salesman Problems</title>
		<author>
			<persName><forename type="first">C</forename><forename type="middle">E</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><forename type="middle">W</forename><surname>Tucker</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Zemlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the Association for Computing Machinery</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="326" to="329" />
			<date type="published" when="1960">1960</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Branch-and-Cut Algorithms for the Capacitated VRP</title>
		<author>
			<persName><forename type="first">D</forename><surname>Naddef</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Rinaldi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The Vehicle Routing Problem</title>
		<title level="s">SIAM Monographs on Discrete Mathematics and Applications</title>
		<editor>
			<persName><forename type="first">P</forename><surname>Toth</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Vigo</surname></persName>
		</editor>
		<meeting><address><addrLine>Philadelphia</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2002">2002</date>
			<biblScope unit="page" from="53" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A Dynamic Programming Approach to the Single-Vehicle, Many-to-Many Immediate Request Dial-a-Ride Problem</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">N</forename><surname>Psaraftis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transportation Science</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="page" from="130" to="154" />
			<date type="published" when="1980">1980</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">An Exact Algorithm for the Single-Vehicle Many-to-Many Dial-a-Ride Problem with Time Windows</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">N</forename><surname>Psaraftis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transportation Science</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="page" from="351" to="357" />
			<date type="published" when="1983">1983</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Polyhedral Solution to the Pickup and Delivery Problem</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Ruland</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995">1995</date>
		</imprint>
		<respStmt>
			<orgName>Sever Institute of Technology, Washington University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Ph.D. thesis</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">The Pickup and Delivery Problem: Faces and Branch-and-Cut Algorithm</title>
		<author>
			<persName><forename type="first">K</forename><forename type="middle">S</forename><surname>Ruland</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">Y</forename><surname>Rodin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computers and Mathematics with Applications</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="page" from="1" to="13" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Local Search in Routing Problems with Time Windows</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W P</forename><surname>Savelsbergh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Annals of Operations Research</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="285" to="305" />
			<date type="published" when="1985">1985</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">The Vehicle Routing Problem with Time Windows: Minimizing Route Duration</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W P</forename><surname>Savelsbergh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ORSA Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="146" to="154" />
			<date type="published" when="1992">1992</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Drive: Dynamic Routing of Independant Vehicles</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">W P</forename><surname>Savelsbergh</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Sol</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Operations Research</title>
		<imprint>
			<biblScope unit="volume">46</biblScope>
			<biblScope unit="page" from="474" to="490" />
			<date type="published" when="1998">1998</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Fast Local Search Algorithms for the Handicapped Persons Transportation Problem</title>
		<author>
			<persName><forename type="first">P</forename><surname>Toth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vigo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Meta-Heuristics: Theory and Applications</title>
		<editor>
			<persName><forename type="first">I</forename><forename type="middle">H</forename><surname>Osman</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">J</forename><forename type="middle">P</forename><surname>Kelly</surname></persName>
		</editor>
		<meeting><address><addrLine>Boston</addrLine></address></meeting>
		<imprint>
			<publisher>Kluwer</publisher>
			<date type="published" when="1996">1996</date>
			<biblScope unit="page" from="677" to="690" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Heuristic Algorithms for the Handicapped Persons Transportation Problem</title>
		<author>
			<persName><forename type="first">P</forename><surname>Toth</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Vigo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transportation Science</title>
		<imprint>
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="60" to="71" />
			<date type="published" when="1997">1997</date>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
