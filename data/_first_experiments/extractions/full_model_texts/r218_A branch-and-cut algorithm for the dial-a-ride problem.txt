Introduction
In the Dial-a-Ride Problem (DARP), users formulate requests for transportation from a specific origin (or pick-up point) to a specific destination (or drop-off point). Transportation is carried out by vehicles that provide a shared service in the sense that several users may be in a vehicle at the same time. The aim is to design a minimum-cost set of vehicle routes accommodating all requests under a number of side constraints. A common DARP application arises in door-to-door transportation services for the elderly and the disabled. In this context, users often formulate two requests per day: an outbound request from home to a destination, and an inbound request for the return trip. Most dial-a-ride services are characterized by the presence of two conflicting objectives: minimizing operating costs and minimizing user inconvenience. Operating costs are mostly related to fleet size and distance traveled while user inconvenience is often measured in terms of deviations from desired pick-up and drop-off times and in terms of excess ride time (i.e., the difference between the actual ride time of a user and the minimum possible ride time). One way to achieve a balance between these objectives is to treat cost minimization as the primary objective and to impose service quality constraints. As in the work of  Jaw et al. (1986)  and  Cordeau and Laporte (2003b) , we assume here that the user specifies either a desired arrival time at destination (in the case of an outbound request) or a desired departure time from the origin (in the case of an inbound request). In both cases, a time window of a pre-specified width is constructed around the desired time. In addition, an upper bound is imposed on the ride time of the user. This approach seems to be in line with the current practice of several North-American transporters. For example, in a system with 15-minute time windows and a maximum ride time of 60 minutes, a user wishing to arrive at destination at 9h00 would be picked-up no earlier than 7h45 and dropped-off between 8h45 and 9h00. It should be emphasized that imposing time windows is not sufficient to accurately impose a maximum ride time. In the above example, a pick-up at 7h45 and a drop-off at 9h would exceed the maximum ride time of 60 minutes. However, constraining the pick-up to take place no earlier than 8h would be too restrictive because it would, in particular, prohibit a pick-up at 7h45 and a drop-off at 8h45. Dial-a-ride services may operate according to a static or to a dynamic mode. In the first case, all requests are known beforehand while in the second case requests are gradually received throughout the day and vehicle routes are adjusted in real-time to meet demand. In practice, pure dynamic problems rarely exist since a large subset of requests is often known in advance. This paper deals with the static variant of the problem. Because it incorporates time windows and maximum ride time constraints, the DARP is a difficult problem that generalizes the Vehicle Routing Problem with Pick-up and Delivery (VRPPD). Finding a feasible solution for the DARP is itself NP-hard since it also generalizes the Traveling Salesman Problem with Time Windows (TSPTW) (see, e.g.,  Savelsbergh, 1985) . As a result most previous work has concentrated on the development of heuristics. Nevertheless, when the problem is moderately constrained, exact solution approaches can be devised to solve small to medium size instances.

Formulation
Let n denote the number of users (or requests) to be served. The DARP may be defined on a complete directed graph G = (N, A) where N = P ∪ D ∪ {0, 2n + 1}, P = {1, . . . , n} and D = {n + 1, . . . , 2n}. Subsets P and D contain pick-up and drop-off nodes, respectively, while nodes 0 and 2n + 1 represent the origin and destination depots. With each user i are thus associated an origin node i and a destination node n + i. Let K be the set of vehicles. Each vehicle k ∈ K has a capacity Q k and the total duration of its route cannot exceed T k . With each node i ∈ N are associated a load q i and a non-negative service duration d i such that q 0 = q 2n+1 = 0, q i = -q n+i (i = 1, . . . , n) and d 0 = d 2n+1 = 0. A time window [e i , l i ] is also associated with node i ∈ N where e i and l i represent the earliest and latest time, respectively, at which service may begin at node i. With each arc (i, j) ∈ A are associated a routing cost c ij and a travel time t ij . Finally, denote by L the maximum ride time of a user. For each arc (i, j) ∈ A and each vehicle k ∈ K, let x k ij = 1 if vehicle k travels from node i to node j. For each node i ∈ N and each vehicle k ∈ K, let B k i be the time at which vehicle k begins service at node i, and Q k i be the load of vehicle k after visiting node i. Finally, for each user i, let L k i be the ride time of user i on vehicle k. The formulation is as follows: Min k∈K i∈N j∈N c k ij x k ij (1) subject to k∈K j∈N x k ij = 1 ∀i ∈ P (2) j∈N x k ij - j∈N x k n+i,j = 0 ∀i ∈ P, k ∈ K (3) j∈N x k 0j = 1 ∀k ∈ K (4) j∈N x k ji - j∈N x k ij = 0 ∀i ∈ P ∪ D, k ∈ K (5) i∈N x k i,2n+1 = 1 ∀k ∈ K (6) B k j ≥ (B k i + d i + t ij )x k ij ∀i ∈ N, j ∈ N, k ∈ K (7) Q k j ≥ (Q k i + q j )x k ij ∀i ∈ N, j ∈ N, k ∈ K (8) L k i = B k n+i -(B k i + d i ) ∀i ∈ P, k ∈ K (9) B k 2n+1 -B k 0 ≤ T k ∀k ∈ K (10) e i ≤ B k i ≤ l i ∀i ∈ N, k ∈ K (11) t i,n+i ≤ L k i ≤ L ∀i ∈ P, k ∈ K (12) max{0, q i } ≤ Q k i ≤ min{Q k , Q k + q i } ∀i ∈ N, k ∈ K (13) x k ij ∈ {0, 1} ∀i ∈ N, j ∈ N, k ∈ K. ( 14 ) The objective function (1) minimizes the total routing cost. Constraints (2) and (3) ensure that each request is served exactly once and that the origin and destination nodes are visited by the same vehicle. Constraints (4)-(  6 ) guarantee that the route of each vehicle k starts at the origin depot and ends at the destination depot. Consistence of the time and load variables is ensured by constraints (  7 ) and (8). Equalities (9) define the ride time of each user which is bounded by constraints (12). It is worth mentioning that the latter also act as precedence constraints because the non-negativity of the L k i variables ensures that node i will be visited before node n + i for every user i. Finally, inequalities (10) bound the duration of each route while (  11 ) and (  13 ) impose time windows and capacity constraints, respectively. This formulation is non-linear because of constraints (  7 ) and (  8 ). Introducing constants M k ij and W k ij , these constraints can, however, be linearized as follows: B k j ≥ B k i + d i + t ij -M k ij (1 -x k ij ) ∀i ∈ N, j ∈ N, k ∈ K (15) Q k j ≥ Q k i + q j -W k ij (1 -x k ij ) ∀i ∈ N, j ∈ N, k ∈ K. ( 16 ) The validity of these constraints is ensured by setting M k ij ≥ max{0, l i + d i + t ij -e j } and W k ij ≥ min{Q k , Q k + q i }. These constraints are very similar to the Miller-Tucker-Zemlin subtour elimination constraints for the TSP  (Miller et al., 1960) . One can reduce the number of variables and constraints in model (  1 )-(  14 ) by using aggregate time variables B i at every node except the origin depot 0 and the destination depot 2n + 1. In this case, one replaces (  7 ) and (  9 ) with the constraints B j ≥ (B k 0 + d 0 + t 0j )x k 0j ∀j ∈ N, k ∈ K (17) B j ≥ (B i + d i + t ij ) k∈K x k ij ∀i ∈ N, j ∈ N (18) B k 2n+1 ≥ (B i + d i + t i,2n+1 )x k i,2n+1 ∀i ∈ N, k ∈ K (19) L i = B n+i -(B i + d i ) ∀i ∈ P, (20) to which the same linearization process can be applied. Along the same lines, if the fleet of vehicles is homogeneous in the sense that Q k = Q for every k ∈ K, one can replace (8) with Q j ≥ (Q k 0 + q j )x k 0j ∀j ∈ N, k ∈ K (21) Q j ≥ (Q i + q j ) k∈K x k ij ∀i ∈ N, j ∈ N (22) Q k 2n+1 ≥ (Q i + q 2n+1 )x k i,2n+1 ∀i ∈ N, k ∈ K. ( 23 ) Finally, as shown by  Desrochers and Laporte (1991) , the linearized form of constraints (  22 ) can be lifted as follows by taking the reverse arc (j, i) into account: Q j ≥ Q i + q j -W ij (1 - k∈K x k ij ) + (W ij -q i -q j ) k∈K x k ji ∀i ∈ N, j ∈ N, k ∈ K. (24) Observe that in our case an equivalent lifting cannot be performed with constraints (18) because waiting will sometimes take place after the beginning of a time window (i.e., B i > e i ) in order to reduce the ride time of a user.

Valid Inequalities
We now describe several families of valid inequalities for the DARP. All of these inequalities are of course redundant for model (1)-(  14 ) but can strengthen its LP-relaxation. Because of the structure of the model, analyzing whether these inequalities define facets of the DARP polytope appears to be a rather challenging task. However, their usefulness is demonstrated through computational experiments in the last section. The following additional notation will be used to describe the valid inequalities. Given a node set S ⊆ N, define δ(S) = δ + (S) ∪ δ -(S) where δ + (S) = {(i, j) ∈ A|i ∈ S, j ∈ S} and δ -(S) = {(i, j) ∈ A|i ∈ S, j ∈ S}. For notational convenience, let x ij = k∈K x k ij denote the total flow on arc (i, j) and define x(S) = i,j∈S x ij . Similarly, let x(A ′ ) = (i,j)∈A ′ x ij for any arc set A ′ ⊆ A.

Bounds on time and load variables
As first suggested by  Desrochers and Laporte (1991)  in the context of the TSP with time windows, bounds on the time variables B i can be strengthened as follows: B i ≥ e i + j∈N \{i} max{0, e j -e i + d j + t ij }x ji (25) B i ≤ l i - j∈N \{i} max{0, l i -l j + d i + t ij }x ij . (26) These inequalities were used, for example, for solving the Asymmetric Travelling Salesman Problem with Time Windows by branch-and-cut  (Ascheuer et al., 2001) . Similarly, bounds on load variables Q i can also be strengthened as follows: Q i ≥ max{0, q i } + j∈N \{i} max{0, q j }x ji (27) Q i ≤ min{Q, Q + q i } -(Q -max j∈N \{i} {q j } -q i )x 0i - j∈N \{i} max{0, q j }x ij . ( 28 )

Subtour elimination constraints
Consider the simple subtour elimination constraint x(S) ≤ |S| -1 for S ⊆ P ∪ D. In the case of the DARP, this inequality can be lifted in two different ways by taking into account the fact that for each user i, node i must be visited before node n + i. Proposition 1. Let S ⊆ P ∪ D and P + (S) = {i|i ∈ S ∩ P and n + i ∈ S}. The following inequality is valid for the DARP: x(S) + i∈P + (S) j∈S x n+i,j ≤ |S| -1. ( 29 ) Proof. Because of precedence relationships, set S must be entered at least once before using any of the lifted arcs. As a result, x(δ -(S)) ≥ 1 + i∈P + (S) j∈S x n+i,j . In addition, x(δ + (S)) = x(δ -(S)) implies that x(δ + (S)) ≥ 1 + i∈P + (S) j∈S x n+i,j . Since 2x(S) + x(δ + (S)) + x(δ -(S)) = 2|S|, one obtains 2x(S) + 2 + 2 i∈P + (S) j∈S x n+i,j ≤ 2|S| and, finally, x(S) + i∈P + (S) j∈S x n+i,j ≤ |S| -1. Example. Consider the node set S = {i, j} ⊆ P . The resulting lifted subtour elimination constraint is x ij + x ji + x n+i,j + x n+j,i ≤ 1. This example is illustrated in Figure  1 . Observe that variables x n+i,i and x n+j,j need not be introduced in the lifted inequality since the corresponding arcs can be trivially removed from the graph. x(S) + i∈S j∈D -(S) x ij ≤ |S| -1. ( 30 ) Proof. The proof is similar to that of Proposition 1 by observing that because of precedence relationships, set S must be exited at least once after using any of the lifted arcs and thus x(δ + (S)) ≥ 1 + i∈S j∈D -(S) x ij . Example. Consider the node set S = {n + i, n + j} ⊆ D. The resulting lifted subtour elimination constraint is x n+i,n+j + x n+j,n+i + x n+i,j + x n+j,i ≤ 1. This is illustrated in Figure  2 . In the case of a directed formulation, one can also lift subtour elimination constraints by taking into account the orientation of the arcs. For a set S = {i 1 , i 2 , . . . , i h } ⊆ N with h ≥ 3 nodes,  Grötschel and Padberg (1995)  proposed the following inequalities for the asymmetric TSP: h-1 j=1 x i j ,i j+1 + x i h ,i 1 + 2 h-1 j=2 x i j ,i 1 + h-1 j=3 j-1 l=2 x i j ,i l ≤ h -1 (31) h-1 j=1 x i j ,i j+1 + x i h ,i 1 + 2 h j=3 x i 1 ,i j + h j=4 j-1 l=3 x i j ,i l ≤ h -1. ( 32 ) Of course, different liftings are obtained by considering different orderings of the nodes in set S. In the case of the DARP, these inequalities can be further lifted by taking precedence relationships into account. This results in the following two propositions. Proposition 3. Let S = {i 1 , i 2 , . . . , i h } ⊆ P ∪ D and P + (S) = {i|i ∈ S ∩ P and n + i ∈ S}. The following inequality is valid for the DARP: h-1 j=1 x i j ,i j+1 + x i h ,i 1 + 2 h-1 j=2 x i j ,i 1 + h-1 j=3 j-1 l=2 x i j ,i l + ip∈P + (S) x n+ip,i 1 ≤ h -1. ( 33 ) Proof. Suppose that one arc of the form (n + i p , i 1 ) with i p ∈ P + (S) is part of the solution. Then all arcs of the form (i j , i 1 ) with 2 ≤ j ≤ h -1 cannot belong to the solution. As a result, if the left-hand side of inequality (  33 ) is larger than h -1, then there exists a subpath linking the h nodes in set S. But because set S contains the origin node i p , this subpath together with the arc (n + i p , i 1 ) would violate the precedence constraint for user i p . Example. Consider the node set S = {i, j, k} ⊆ P . One possible lifted directed subtour elimination constraint (obtained with i 1 = i, i 2 = j, i 3 = k) is x ij + x jk + x ki + 2x ji + x n+j,i + x n+k,i ≤ 2. This is illustrated in Figure 3. n+j i j k n+k 2 Figure 3: Lifted directed subtour elimination constraint for S = {i, j, k} ⊆ P Proposition 4. Let S = {i 1 , i 2 , . . . , i h } ⊆ P ∪ D and D -(S) = {i|n + i ∈ S ∩ D and i ∈ S}. The following inequality is valid for the DARP: h-1 j=1 x i j ,i j+1 + x i h ,i 1 + 2 h j=3 x i 1 ,i j + h j=4 j-1 l=3 x i j ,i l + ip∈D -(S) x i 1 ,ip ≤ h -1. ( 34 ) Proof. The proof is similar to that of Proposition 3 by observing that if one arc of the form (i 1 , i p ) with i p ∈ D -(S) is part of the solution, then all arcs of the form (i 1 , i j ) with 3 ≤ j ≤ h cannot belong to the solution. Example. Consider the node set S = {n + i, n + j, n + k} ⊆ D. One possible lifted directed subtour elimination constraint (obtained with  i 1 = n + i, i 2 = n + j, i 3 = n + k) is x n+i,n+j + x n+j,n+k + x n+k,n+i + 2x n+i,n+k + x n+i,j + x n+i,k ≤ 2. This is illustrated in Figure 4.

Capacity constraints
For any subset S ⊆ P ∪D, let R(S) denote the minimum number of vehicles needed to visit all nodes in S. The constraint x(δ(S)) ≥ 2R(S) is then a valid inequality. Although computing R(S) is difficult, a lower approximation is provided by ⌈q(S)/Q⌉ where q(S) = i∈S q i . The resulting inequality is called a rounded capacity inequality in the context of the VRP. While capacity inequalities play an important role in most branch-and-cut algorithms for the VRP (see, e.g.,  Naddef and Rinaldi, 2002) , they are not likely to be very strong for the DARP because of the presence of both positive and negative q i values. In particular, q(P ∪ D) = 0 by definition and, in the absence of time windows, all nodes can be visited by the same vehicle. Useful inequalities can, however, be obtained by restricting S to be a subset of either P or D and setting q(S) = | i∈S q i |. It should be emphasized that in our context, the quantity ⌈q(S)/Q⌉ estimates the required number of vehicle passages in set S rather than the number of vehicles per se. Indeed, by leaving and entering set S more than once, the same vehicle may be able to visit all nodes in the set even though q(S) > Q.

Precedence constraints
Consider a node set S such that 0 ∈ S, i ∈ S, n + i ∈ S and 2n + 1 ∈ S for at least one user i. Because node i must be visited before node n + i, x(S) ≤ |S| -2 and, equivalently, x(δ(S)) ≥ 4. The same applies to node sets S such that 0 ∈ S, i ∈ S, n + i ∈ S and 2n + 1 ∈ S for at least one user i. These inequalities, which are also valid for the DARP, were introduced by Ruland and Rodin (1997) for the pickup and delivery problem.

Generalized order constraints
Let U 1 , . . . , U m ⊂ N be mutually disjoint subsets and let i 1 , . . . , i m ∈ P be users such that 0, 2n + 1 ∈ U l and i l , n + i l+1 ∈ U l for l = 1, . . . , m (where i m+1 = i 1 ). The following inequality, introduced by Ruland and Rodin (1997), is also valid for the DARP: m l=1 x(U l ) ≤ m l=1 |U l | -m -1. ( 35 ) In the directed case, these inequalities can be lifted in two different ways, as shown by the following propositions. Proposition 5. The following inequality is valid for the DARP: m l=1 x(U l ) + m-1 l=2 x i 1 ,i l + m l=3 x i 1 ,n+i l ≤ m l=1 |U l | -m -1. ( 36 ) Proof. First observe that in any feasible integer solution, at most one of the lifted arcs may be part of the solution since they all belong to δ + (i 1 ). To demonstrate the validity of the lifting, we show that if any of the lifted arcs is part of the solution then there are at least two subsets U l for which x(U l ) ≤ |U l | -2. Since x(U l ) ≤ |U l | -1 for all other subsets, the validity of the inequality follows directly. The details of the proof are given in the appendix. Remark 1. The numbering of the sets U 1 , . . . , U m is arbitrary and leads, by symmetry, to m! possibly different liftings. Example. Consider the subsets U 1 = {i, n + j}, U 2 = {j, n + k} and U 3 = {k, n + i} with i 1 = i, i 2 = j and i 3 = k. The lifted generalized order constraint is x i,n+j + x n+j,i + x j,n+k + x n+k,j + x k,n+i + x n+i,k + x ij + x i,n+k ≤ 2. This is illustrated in Figure  5 .  m l=1 x(U l ) + m-2 l=2 x n+i 1 ,i l + m-1 l=2 x n+i 1 ,n+i l ≤ m l=1 |U l | -m -1. ( 37 ) Proof. The reasoning is similar to that of Proposition 5 and the details of the proof are given in the appendix. Example. Consider the subsets U 1 = {i, n + j}, U 2 = {j, n + k} and U 3 = {k, n + i} with i 1 = i, i 2 = j and i 3 = k. The lifted generalized order constraint is x i,n+j + x n+j,i + x j,n+k + x n+k,j + x k,n+i + x n+i,k + x n+i,n+j ≤ 2. This is illustrated in Figure  6 . Observe that in inequality (37), the value of m must be larger than or equal to 4 for the second term of the inequality to have any effect. 

Order matching constraints
Consider two nodes i, j ∈ P and a subset H such that {i, j} ⊆ H ⊆ N \{0, n+i, n+j, 2n+1}. The following inequality, introduced by Ruland and Rodin (1997), is also valid for the DARP: x(H) + x({i, n + i}) + x({j, n + j}) ≤ |H|. ( 38 ) As suggested by  Ruland (1995) , this inequality can be lifted by introducing the term x({h, n + h}) for every user h such that h ∈ H and n + h ∈ H. In the directed case, order matching constraints are in fact redundant because any arc of the form (n + h, h) can be removed from the graph. As a result, all arcs in the left-hand side of (38) have their origin node in set H. Hence, the sum of the flows on these arcs cannot exceed |H|, even in a fractional solution. Order matching constraints can, however, be generalized by replacing the arcs (h, n + h) by node sets. This leads to the following proposition. Proposition 7. Let i 1 , . . . , i m be m users and let H ⊂ P ∪ D and T h ⊂ P ∪ D, h = 1, . . . , m be node sets such that {i h , n + i h } ⊆ T h and H ∩ T h = {i h }. The following inequality is valid for the DARP: x(H) + m h=1 x(T h ) ≤ |H| + m h=1 |T h | -2m. ( 39 ) Proof. First observe that x(H) ≤ |H| -1 and x(T h ) ≤ |T h | -1 for h = 1, . . . , m. If x(T h ) = |T h | -1 for any given subset T h , then there exists a path connecting all nodes in T h , including i h and n+i h . However, this path cannot finish at node i h because of the precedence constraint for user i h . Let α be the number of sets T h for which x(T h ) = |T h | -1. Then, x(δ + (H)) ≥ α. Since x(δ + (H)) = x(δ -(H)) and 2x(H) + x(δ + (H)) + x(δ -(H)) = 2|H|, one obtains that 2x(H) ≤ 2|H| -2α and thus x(H) ≤ |H| -α. Finally, because x(T h ) ≤ |T h | -2 for the remaining m -α sets, one may conclude that x(H) + m h=1 x(T h ) ≤ |H| -α + m h=1 (|T h | -1) -(m -α) , which simplifies to expression (39). Example. Consider the sets H = {i, j}, T 1 = {i, n + i, k} and T 2 = {j, n + j, l} with i 1 = i and i 2 = j. The resulting inequality is x(H)+x(T 1 )+x(T 2 ) ≤ 4 and is illustrated in Figure  7 . 

Infeasible path inequalities
Ride time constraints may give rise to paths that are infeasible in an integer solution but nonetheless feasible in a fractional solution. Forbidding such paths can be accomplished through the valid inequality introduced in the next proposition. Proposition 8. For any directed path P = {i, k 1 , k 2 , . . . , k p , n + i} such that t i,k 1 + d k 1 + t k 1 ,k 2 + d k 2 + • • • + t kp,n+i > L the following inequality is valid for the DARP: x i,k 1 + p-1 h=1 x k h ,k h+1 + x kp,n+i ≤ p -1. ( 40 ) Proof. Suppose that the value of the left-hand side of inequality (  40 ) is equal to p in a feasible integer solution. Then there is a single arc from path P not belonging to the solution because the path contains p + 1 arcs. Since the solution is feasible, it must contain a path from i to n + i in which the missing arc has been replaced by at least two other arcs. But if the triangle inequality holds for travel times, the path from i to n + i has a larger duration than that of P. As a result, its duration must exceed L, which contradicts the assumption that the solution is feasible. Remark 3. As will be shown in the next section, the case p = 1 can be handled directly through the simple elimination of arcs in a preprocessing step. 5 Branch-and-Cut Algorithm Branch-and-cut is a popular approach for solving combinatorial problems. It has been applied successfully to several routing problems (see, e.g.,  Ascheuer et al., 2001; Gendreau et al., 1998; Naddef and Rinaldi, 2002) . This section describes the branch-and-cut algorithm used for the DARP. It focuses on the preprocessing techniques developed to reduce problem size and on the separation heuristics used to identify violated inequalities. After applying the preprocessing steps presented in Section 5.1, the algorithm first solves the LP relaxation of the problem. If the solution to the LP relaxation is integer, an optimal solution has been identified. Otherwise, an enumeration tree is constructed and violated valid inequalities are generated at some nodes of this tree by means of the separation heuristics described in Section 5.2. To control the branch-and-cut process, additional variables y k i = j∈N x k ij are introduced in the formulation. At each node of the search tree, if the y k i variables are all integer in the current relaxation but there is at least one fractional x k ij variable, the separation heuristics are executed in the hope of identifying violated valid inequalities. If at least one of the heuristics succeeds in finding one or more violated inequalities, the relaxation is solved with all identified cuts and the heuristics are executed again. The cut generation process at a node terminates when all heuristics fail to find any violated inequality. If the solution to the relaxation is still fractional after the generation of cuts, branching is performed on a fractional y k i variable, if there is any, or on a fractional x k ij variable, otherwise. The variable selected for branching is that whose value is the farthest from the nearest integer. Prior to the application of the branch-and-cut algorithm, an upper bound is computed by using the tabu search heuristic of  Cordeau and Laporte (2003b) . This upper bound is then used to prune the enumeration tree whenever the solution value at a given node exceeds that of the upper bound. Finally, an initial set of valid inequalities is added prior to solving the initial LP relaxation: all bounds on time and load variables, lifted 2-node subtour elimination constraints, generalized order constraints with m = 2 and |U l | = 2, and precedence constraints with |S| = 3 are introduced in a pool of cuts whose violations are checked at each node of the branch-andbound tree, including those where not all y variables take integer values.

Preprocessing
This section describes the time window tightening, arc elimination and variable fixing steps that can be applied prior to the branch-and-cut algorithm.

Time window tightening
Let T denote the end of the planning horizon. In the case of an outbound user, the time window at the origin node can be tightened by setting e i = max{0, e n+i -L -d i } and l i = min{l n+i -t i,n+i -d i , T }. In the case of an inbound user, the time window at the destination node can be tightened by setting e n+i = max{0, e i +d i +t i,n+i } and l n+i = min{l i +d i +L, T }. The time window on nodes 0 and 2n + 1 can also be tightened by setting e 0 = e 2n+1 = min i∈P ∪D {e i -t 0i } and l 0 = l 2n+1 = max i∈P ∪D {l i + d i + t i,2n+1 }.

Arc elimination
Formulation (1)-(  14 ) is defined on a complete graph G. However, because of time windows, pairing and ride time constraints, several arcs can in fact be removed from the graph as they cannot belong to a feasible solution. A simple analysis leads to the following observations: • arcs (0, n + i), (i, 2n + 1) and (n + i, i) are infeasible for i ∈ P ; • arc (i, j) with i, j ∈ N is infeasible if e i + d i + t ij > l j ; • arcs (i, j) and (j, n + i) with i ∈ P, j ∈ N are both infeasible if t ij + d j + t j,n+i > L. As first proposed by  Dumas et al. (1991) , combining time windows and pairing constraints leads to even stronger elimination rules: • arc (i, n + j) is infeasible if path P = {j, i, n + j, n + i} is infeasible; • arc (n + i, j) is infeasible if path P = {i, n + i, j, n + j} is infeasible; • arc (i, j) is infeasible if paths P 1 = {i, j, n + i, n + j} and P 2 = {i, j, n + j, n + i} are both infeasible; • arc (n + i, n + j) is infeasible if paths P 1 = {i, j, n + i, n + j} and P 2 = {j, i, n + i, n + j} are both infeasible. In the presence of ride time constraints, further elimination can be performed by identifying pairs of users that are incompatible (i.e., that cannot be assigned to the same vehicle) because of the interaction between time windows and ride time constraints. Incompatible user pairs {i, j} can be identified by checking the feasibility of the following paths: {i, j, n + i, n + j}, {i, j, n + j, n + i}, {j, i, n + i, n + j}, {j, i, n + j, n + i}, {i, n + i, j, n + j}, {j, n + j, i, n + i}. If none of these six paths is feasible, then all eight arcs between {i, n + i} and {j, n + j} can be eliminated. Because of ride time constraints, checking the feasibility of a path is not always straightforward. In the case of the path {i, j, n + i, n + j}, for example, setting B i = e i may lead to the violation of the ride time constraint for user i in the event that unnecessary waiting time then occurs at node j. For this reason, the forward time slack should be computed at node i so as to delay the beginning of service as much as possible without violating any of the time windows. The same can be said about node j where the beginning of service should be delayed as much as possible by taking into account the additional constraint that the maximum ride time for user i should not be exceeded. In general, the forward time slack F i at node i in a path {i, i + 1, . . . , q} can be computed as follows: F i = min i≤j≤q i<p≤j W p + min {l j -B j , L -P j } , (41) where W i denotes the waiting time at node i, P i denotes the ride time of the user whose destination node is i if n + 1 ≤ i ≤ 2n, and P i = -∞, otherwise. This definition of the forward time slack generalizes that of  Savelsbergh (1992)  for the TSP with time windows.

Variable fixing
The identification of incompatible user pairs can also be used to permanently assign users to specific vehicles. If the fleet of vehicles is homogeneous, one can can create a graph G ′ = (N ′ , E ′ ) where N ′ = {1, . . . , n} and E ′ contains an edge (i, j) if i and j are incompatible users. Given a clique in G ′ , each user in the clique can be assigned to a different vehicle. In addition, if user i is assigned to vehicle k, constraints can be added to the formulation so as to forbid the assignment to vehicle k of users that are incompatible with i. Finding a clique of maximum cardinality in G ′ may be very time consuming when n is large. In our implementation, we thus use a greedy heuristic described by  Johnson (1974) .

Separation Heuristics
This section describes the separation heuristics used to identify violated inequalities. When all y k i variables are integer but there is at least one fractional x k ij variable, the following heuristics are executed sequentially.

Subtour elimination constraints
The identification of violated inequalities of the form x(S) ≤ |S|-1 can be achieved by solving a series of maximum flow problems between any node i and all other nodes j ∈ N \ {i}. However, in addition to being time-consuming, this approach does not take the possible liftings into account. For these reasons, we resort to a simple tabu search heuristic inspired from that proposed by  Augerat et al. (1999) . Using the fact that 2x(S) + x(δ(S)) = 2|S| in a feasible integer solution, violations of (  29 ) can be identified by finding node sets S such that x(δ(S)) -2 i∈P + (S) j∈S x n+i,j < 2. ( 42 ) The heuristic starts with an empty set S. At each iteration, it either adds or removes a node from the set S so as to minimize the left-hand side of (42). Whenever a node is removed from set S, its reinsertion is declared tabu for θ iterations. The heuristic runs for a preset number of iterations (100 in our implementation) and may identify several violated inequalities during a single execution. At each iteration, the current set S is also checked for possible violations of inequality (33). To this purpose, the node with the largest outgoing flow is numbered as i 1 and the other nodes are numbered at random. A similar heuristic is used to identify violations of inequalities (  30 ) and (  34 ). In the latter case, the node with the largest incoming flow is numbered as i 1 .

Capacity constraints
Again, we use a tabu search heuristic to identify sets S such that q(S) > Q and x(δ(S)) < 4. The heuristic starts either with a random subset S ⊆ P or with a random subset S ⊆ D. At each iteration, a node is either removed or added to the set S so as to minimize the value of x(δ(S)), with the constraint that q(S) > Q. Again, the heuristic runs for 100 iterations and multiple violated inequalities may be identified during a single execution.

Precedence constraints
As explained by  Ruland (1995) , identifying violated precedence constraints can be done by solving a multi-terminal maximum flow problem for each user. To check whether the precedence constraint for user i is violated, one can compute the maximum flow from the sources 0 and n + i to the sinks i and 2n + 1. If the value of this flow is less than 2, then a precedence constraint x(S) ≤ |S| -2 is violated for a set S such that 0, n + i ∈ S and i, 2n + 1 ∈ S. The set S corresponds to one of the shores of the corresponding minimum cut. We have implemented this approach and use the maximum flow algorithm provided in the GTL library (see  http://infosun.fmi.uni-passau.de/GTL ).

Generalized order constraints
Ruland  (1995)  proposed an approach to identify violated generalized order constraints with m = 2. This approach requires the computation of O(|N| 2 ) maximum flows. Here, we use instead three simple heuristics, the second and third of which take advantage of the lifted forms (  36 ) and (37). The first heuristic attempts to identify violations of inequalities (35) for the special case where m = 2 and |U 1 | = |U 2 | = 3. For each pair of users i, j ∈ P , we first form the subsets U 1 = {i, n + j} and U 2 = {j, n + i}. We then identify nodes k 1 and k 2 such that x(U 1 ) and x(U 2 ) are maximized, and check for a violation of the resulting inequality. The second and third heuristics are aimed at finding violations of inequalities (  36 ) and (  37 ) for the special case where m = 3 and |U 1 | = |U 2 | = |U 3 | = 2. The second heuristic finds, for each user i, a user j that maximizes x i,n+j + x n+j,i + x ij . It then finds a user k such that the left-hand side of (  36 ) is maximized. Similarly, the third heuristic finds, for each user i, a user j that maximizes x i,n+j + x n+j,i + x n+i,n+j and then finds a user k that maximizes the left-hand side of (37).

Order matching constraints
To identify violated order matching constraints,  Ruland (1995)  has proposed an algorithm requiring the solution of O(|N| 2 ) maximum flow problems. We again resort to a simpler heuristic that aims to identify violations of (39) for the special case where m = 2, |H| = 3 and |T 1 | = |T 2 | = 3. For each pair of users i, j ∈ P , we first form the subsets T 1 = {i, n + i} and T 2 = {j, n + j}. We then select the nodes k 1 and k 2 such that x(T 1 ) and x(T 2 ) are maximized. Finally, we select the node k such x(H) is maximized and check for a violation of the resulting inequality.

Infeasible path inequalities
Violated path inequalities are identified by means of a path-construction heuristic applied to each user i ∈ P . The heuristic starts with node i and gradually constructs a path P i = {i, k 1 , k 2 , . . . } by iteratively moving from the current node k j to the node k l that maximizes the value of x k j k l . The process stops if a cycle is formed or if the heuristic reaches either node n + i or node 2n + 1. If the path stops at node n + i, it is checked for a violation of inequality (40).

Computational Experiments
The branch-and-cut algorithm just described was implemented in C++ by using ILOG Concert 1.3 and CPLEX 8.1. It was run on a 2.5 GHz Pentium 4 computer with 512Mb of memory. The algorithm was applied to two sets of randomly generated instances comprising up to 32 users. In an instance with n users, where n is even, users 1, . . . , n/2 are assumed to formulate outbound requests while users n/2 + 1, . . . , n formulate inbound requests. In all instances, the coordinates of pick-up and drop-off nodes are randomly and independently chosen in the square  [-10, 10 ] × [-10, 10] according to a uniform distribution, and the depot is located at the center of this square. For every arc (v i , v j ) ∈ A, the routing cost c ij and travel time t ij are equal to the Euclidean distance between the two nodes. A time window [e i , l i ] is also associated to each node. For an outbound user i, a time window was generated by first choosing a number e n+i in the interval [420, 1080] (i.e., between 7h00 and 18h00) and then setting l n+i = e n+i +15. For an inbound user, the value of e i was chosen in the interval [360, 1020] and the value of l i was set equal to e i + 15. Time windows on the origin nodes of outbound requests and on the destination nodes of inbound requests are set as explained in Section 5.1.1. In the first set of instances, Q = 3 for every vehicle, q i = 1 for every user and the maximum ride time L is equal to 30 minutes. In the second set, Q = 6 for every vehicle and the values of q i are chosen randomly according to a uniform distribution on the set {1, . . . , Q}. The maximum ride time is set equal to 60 minutes. In all cases, we assume that service time is proportional to the number of passengers and d i = q i . The maximum route duration is set to 720 minutes. The first set of instances represents the context where cars are used for the transportation of individuals whereas the second set reflects the situation of a transporter using mini-busses for the transportation of individuals or groups of individuals. Tables  1  and 2  provide the characteristics of these instances, the number of constraints and variables in the resulting integer programming formulation, the value of the LP relaxation and the cost of a heuristic solution. This solution was obtained by running the tabu search algorithm of  Cordeau and Laporte (2003b)  for 1000 iterations. In Tables  3  and 4  we indicate the best lower bounds reached by running the branch-andcut algorithm on each instance with a maximum CPU time limit of 60 minutes. Column CPLEX indicates the bound obtained by running CPLEX itself with no user-cut generation but after the application of the preprocessing steps of Section 5.1. The next columns report the bounds obtained by generating the lifted bounds on time and load variables (Section 4.1) with only one of the following: subtour eliminations constraints (SEC), capacity constraints (CC), generalized order constraints (GOC), order matching constraints (OMC) and infeasible path constraints (IPC). Average values reported on the last line of each table show that the strength of the various inequalities varies from one set of instances to the other. Furthermore, for the first set of instances, using any kind of inequality alone did not yield significantly better bounds than using CPLEX directly, except for subtour elimination constraints. This is explained by the fact that the additional CPU time used to identify violated inequalities allows for the exploration of a reduced number of nodes in the search tree. We do not report the results for the generation of precedence constraints since these were significantly worse than the direct CPLEX implementation. Combining the different types of inequalities does, however, yield important improvements over the basic version of CPLEX. Tables  5  and 6  reports the results obtained by using the basic version of CPLEX and by using the five types of inequalities concurrently. In both cases, a maximum of 12 hours of CPU time was allowed for the solution of each instance. We report the best bound obtained, the CPU time used and the number of nodes explored in the branch-and-bound tree. For the branch-and-cut algorithm, we also indicate the total number of user cuts generated. An asterisk preceding a lower bound indicates that the instance was solved to optimality. One can observe that the branch-and-cut algorithm is significantly faster than using CPLEX alone. For the 19 instances solved to optimality by both approaches within the time limit, the average CPU time was 118.60 minutes for CPLEX compared with 33.02 minutes for the branch-and-cut algorithm. The average number of nodes explored went down from 351,623 to 61,584. For the eight instances that could not be solved optimally by any of the two approaches, the average lower bound reached by CPLEX was 377.12 compared with 393.36 for the branch-and-cut algorithm. Finally, the branch-and-cut algorithm solved three more instances to optimality. The small number of cuts generated with respect to the number of nodes explored in the branch-and-bound tree is explained by the fact that the separation procedures are executed only when all y k i variables are integer. For most instances, this occurs at approximately 5% of the nodes. Experiments performed with the generation of cuts at every node of the tree have produced slightly worse results because of the extra time spent by the separation procedures. It is likely that a larger number of cuts could be generated by using exact or more sophisticated heuristic separation procedures. The development of such procedures is by itself an important area of research that will be addressed in future work. 

Conclusion
We have introduced several new valid inequalities and a branch-and-cut algorithm for the dial-a-ride problem. Although no polyhedral analysis was carried out, the usefulness of these inequalities has been demonstrated through computational experiments. A comparison with version 8.1 of CPLEX shows that the branch-and-cut algorithm proposed here reduces both the CPU time and the number of nodes explored in the branch-and-bound tree. The methodology proposed in this paper obviously cannot be used to solve large-scale instances containing hundreds or thousands of users as it is sometimes the case in large cities. It is, however, fast enough to be used as a post-processor to optimize individual routes or small subsets of routes produced by a meta-heuristic. In the presence of ride time constraints, using dynamic programming would be difficult since the states of the dynamic programming algorithm would have to take into account the individual ride time of each user. Future work will concentrate on the development of more refined separation procedures for the various types of inequalities introduced in this paper. for U 1 must visit node n + i 2 before visiting node i 1 . In addition, this path must appear immediately before the arc (i 1 , n + i l ) in the solution. Now, for k = 2, . . . , l -1, the path for U k must appear before that for U k-1 in the solution to avoid violating the precedence constraint for user i k . But for k = l -1, this implies that node n + i l appears before node i 1 , which is a contradiction since the arc (i 1 , n + i l ) is part of the solution. Next, we show that for there is at least one subset U k with l ≤ k ≤ m for which x(U k ) ≤ |U k | -2. Suppose this is not true. Since the arc (i 1 , n + i l ) is in the solution, then for k = l, . . . , m, the path for U k must appear before the arc (i 1 , n + i l ) in the solution to avoid violating the precedence constraint for user i k . But for k = m, this implies that the path connecting i m and n + i 1 appears before node i 1 , which is a contradiction. Details of the proof of Proposition 6. Again, there are two cases to distinguish. Case 1. An arc (n + i 1 , i l ) with 2 ≤ l ≤ m -2 is part of the solution. For k = l -1, . . . , 1, the path connecting i k and n + i k+1 must appear after the arc (n + i 1 , i l ) in the solution to avoid violating the precedence constraint for user i k+1 . But for k = 1 this implies that the path connecting i 1 and n + i 2 appears after the arc (n + i 1 , i l ), which is a contradiction. Since the arc (n+ i 1 , i l ) is in the solution, the subpath for U l must visit node i l before visiting node n + i l+1 . For k = l + 1, . . . , m, the path for U k must appear before that for U k-1 to avoid violating the precedence constraint for user i k . But for k = m, this implies that the path connecting i m and n + i 1 appears before the path for at least one other subset U h with l + 1 ≤ h ≤ m -1, and thus node n + i 1 appears in two different places in the solution. Case 2. An arc (n + i 1 , n + i l ) with 2 ≤ l ≤ m -1 is part of the solution. For k = 1, . . . , l-1, the path connecting i k and n+i k+1 must appear after the arc (n+i 1 , n+i l ). But for k = 1, this implies that node i 1 appears after node n + i 1 , which is a contradiction. The path for U l must appear before the arc (n + i 1 , n + i L ) and, for k = l + 1, . . . , m -1, the path for U k must appear before that for U k-1 . But for k = m, this implies that the path connecting i m and n + i 1 appears before the path for at least one other subset U h with l ≤ h ≤ m -1, and thus node n + i 1 appears in two different places in the solution.